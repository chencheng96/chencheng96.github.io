






<!doctype html>
<html>
<head>
<title>Python组合数据类型_comonly.cn</title>
<meta name="keywords" content="Python组合数据类型" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="/css/css_yangqingqing.css" rel="stylesheet">
</head>
<body>
<div class="box">
 <div class="blank"></div>
 <div class="infosbox">
    <div class="newsview">
      <h3 class="news_title">Python组合数据类型</h3>
      <div class="bloginfo">
        <ul>
          <li class="author"></li>
          <li class="lmname"><a href="" target="_blank"></a></li>
          <li class="timer">2018-02-22</li>
          	
         
          
          <!-- origin -->
		  <li class="view">
 

	python  perl
 	  	
		  </li>		  
		  <li class="view">公开</li>

 
          <!-- 
          <li class="view">4567已阅读</li>
          <li class="like">8888888</li>
           -->
        </ul>
      </div>
      
        <div class="tags"><a href="/" target="_blank">序列,集合,映射</a></div>
      
      
      <!-- <div class="news_con"> -->
      <div class="realContent_kindeditor"> <h2 id='序列类型'>
	序列类型
</h2>
<p>
	序列类型支持成员关系操作符（in），大小计算函数（len()），分片（[]），并且是可以迭代的。5种内置的序列类型：bytearray，bytes，list，str与tuple。
</p>
<h4>
	元组
</h4>
<p>
	与字符串一样，元组支持分片与步距的语法。元组是固定的，不能替换或删除其中包含的任意数据项（若需要修改应使用列表，可以使用list()函数将元祖转换为列表）。
</p>
<p>
	tuple()可以作为函数调用，不指定参数时返回一个空元组。元组一般包含在圆括号中()。
</p>
<p>
	提供了两种方法（不包含x时，产生ValueError异常）：
</p>
<ul>
	<li>
		t.count(x)，返回对象x在元组中出现的次数。
	</li>
	<li>
		t.index(x)，返回对象在元组t中的最左边位置。
	</li>
</ul>
<p>
	元组可以使用操作符+（连接），*（赋值），[]（分片）。也可以使用 in 与 not in 测试成员关系。+=，*=也可以使用（实际上Python创建了新元组，用于存放结果，并把对象引用设置为指向新元组）。
</p>
<p>
	元组可以使用标准的比较操作符（&lt;, &lt;=, ==, !=, &gt;=, &gt;）进行比较（逐项进行的）
</p>
<pre class="prettyprint lang-py">&gt;&gt;&gt; color="red","black","write"
&gt;&gt;&gt; color[2]        #分片
'write'
&gt;&gt;&gt; color[::-1]      #步距
('write', 'black', 'red')
&gt;&gt;&gt;
&gt;&gt;&gt; color[:2],"gray",color[2:]
(('red', 'black'), 'gray', ('write',))
&gt;&gt;&gt;
&gt;&gt;&gt; color[:2]+"gray"+color[2:]      #元组的+不能是元组与字符串
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate tuple (not "str") to tuple
&gt;&gt;&gt;
&gt;&gt;&gt; color[:2]+("gray",)+color[2:]       #只有元组才能用+
('red', 'black', 'gray', 'write')</pre>
<h4>
	命名的元组
</h4>
<p>
	可以根据名称引用元组中的项，就像根据索引位置一样。collections模块提供了namedtuple()函数，用于创建自定义的元组数据类型。
</p>
<pre class="prettyprint lang-py">&gt;&gt;&gt; import collections
&gt;&gt;&gt; Sale=collections.namedtuple("Sale","productid customerid date quantity price")
&gt;&gt;&gt; a=Sale(432,921,"2008-09-14",3,7.99)
&gt;&gt;&gt; b=23,a,"safe"
&gt;&gt;&gt; b[1].date      #使用名称引用
'2008-09-14'</pre>
<h4>
	列表
</h4>
<p>
	支持与字符串以及元组一样的分片与步距语法。列表是可变的（字符串，元组不可变），可以对元组中的项进行删除，插入，替换。
</p>
<p>
	list()可以作为函数调用。不带参数返回一个空列表。包含一个或多个项的列表可以使用“,”分割项（包含在[]中）创建。可<span>以使用标准的比较操作符（&lt;, &lt;=, ==, !=, &gt;=, &gt;）进行比较（逐项进行的）。列表支持嵌套，迭代（for item in L:），分片等操作。可以用del语句。</span> 
</p>
<p>
	一次提取两个或多个数据项可以使用序列拆分实现。任意可迭代的（列表，元组等）数据类型都可以使用序列拆分操作符（*）进行拆分。若一个列表 L 中存放的是函数的几个参数，可以直接通过 *L 传递参数。
</p>
<pre class="prettyprint lang-py">&gt;&gt;&gt; (first,*last)=(2,4,-2,3,9)
&gt;&gt;&gt; first,last
(2, [4, -2, 3, 9])
&gt;&gt;&gt;
&gt;&gt;&gt; a,*b,c="this is a string !".split()
&gt;&gt;&gt; a,b,c
('this', ['is', 'a', 'string'], '!')</pre>
列表的内置函数
<pre class="prettyprint lang-py">&gt;&gt;&gt; woods=["Yew","Read"]
&gt;&gt;&gt; woods+=["equal"]      #扩展列表
&gt;&gt;&gt; woods
['Yew', 'Read', 'equal']
&gt;&gt;&gt; woods.extend(["exten"])
&gt;&gt;&gt; woods
['Yew', 'Read', 'equal', 'exten']
&gt;&gt;&gt; woods[2:2]=["pin"]      #在索引位置处插入新的数据项
&gt;&gt;&gt; woods
['Yew', 'Read', 'pin', 'equal', 'exten']
&gt;&gt;&gt; woods.insert(2,"pine")
&gt;&gt;&gt; woods
['Yew', 'Read', 'pine', 'pin', 'equal', 'exten']
&gt;&gt;&gt; woods[1]='red'
&gt;&gt;&gt; woods
['Yew', 'red', 'pine', 'pin', 'equal', 'exten']
&gt;&gt;&gt; woods[1:5]=["qu","blu"]      #替换分片，可能缩短列表长度
&gt;&gt;&gt; woods
['Yew', 'qu', 'blu', 'exten']
&gt;&gt;&gt; woods.pop(2)      #移除并返回特定索引处的数据项。
'blu'
&gt;&gt;&gt; woods
['Yew', 'qu', 'exten']
&gt;&gt;&gt; del woods[1:2]      #移除单个或多个数据项
&gt;&gt;&gt; woods
['Yew', 'exten']
&gt;&gt;&gt; woods.reverse()      #列表反转
&gt;&gt;&gt; woods
['exten', 'Yew']
&gt;&gt;&gt; sorted(woods)      #对列表排序
['Yew', 'exten']
&gt;&gt;&gt; woods.sort(key=str.lower)      #key指定一个用于每个数据项的函数，其返回值进行排序
&gt;&gt;&gt; woods
['exten', 'Yew']
&gt;&gt;&gt; reversed(woods)      #……
&lt;list_reverseiterator object at 0x0000020D9AC402E8&gt;
&gt;&gt;&gt; woods
['exten', 'Yew']</pre>
<h4>
	列表内涵
</h4>
<p>
	基本形式 [item for item in iterable]，返回一个列表，其中包含iterable中的每个数据项，在语义上和list(iterable)一致。任何列表内涵都可以使用一个或多个for……in循环重写。
</p>
<pre class="prettyprint lang-py">MF=["Male","Female"]
SMLX=["Small","Medium","Large"]
BGW=["Black","White"]
codes=[]
for sex in MF:
   for size in SMLX:
      if sex=="Female" and size=="Large":
         continue
      for color in BGW:
         codes.append(sex+size+color)  #追加列表项
print(codes)
#使用列表内涵实现循环相同的功能
code_s=[sex+size+color for sex in MF for size in SMLX for color in BGW
        if not(sex=="Female" and size=="Large")]
print(code_s)</pre>
<h2 id='集合类型'>
	集合类型
</h2>
<p>
	<span>set也是一种组合数据类型，支持成员关系操作符（in），大小计算函数（len()），</span>并且也是 iterable。集合数据类型至少提供一个set.isdisjoint()方法，支持比较，支持位逻辑操作符（集合用于联合，交叉等上下文中使用）。Python提供两种内置的集合类型：可变的set类型，固定的frozenset类型。进行迭代是集合以任意顺序提供数据项。只有可哈希运算的对象可以添加到集合中。所有内置固定数据类型（float, frozenset, int, str, tuple）都是可哈希的，可以添加到集合中。内置可变数据类型（dict, list, set）都不是可哈希的，哈希值会随项数改变。
</p>
<p>
	<span>使用标准的比较操作符（&lt;, &lt;=, ==, !=, &gt;=, &gt;）进行比较（逐项进行的）。</span> 
</p>
<p>
	集合可变，但是无序，没有索引的概念。
</p>
<p>
	set()可以作为函数调用。包含一个或多个项的集合可以通过逗号分隔的数据项（包含在大括号{}中）序列来创建。
</p>
<p>
	set("apple"), set("aple"), {'a','p','l','e'}是完全一样的，所以可以用set来删除重复的数据。
</p>
<h4>
	集合内涵
</h4>
<p>
	{expression for item in iterable if condition}带有可选条件的循环，与列表类似。html={x for x in files if x.lower().endswith((".htm",".html"))}
</p>
<h4>
	固定集合
</h4>
<p>
	一旦创建不能修改。frozenset()返回一个空的固定集合。
</p>
<p>
	二元运算符应用于集合与固定集合，产生结果的数据类型与左边操作数的数据类型一致。
</p>
<h2 id='映射类型'>
	映射类型
</h2>
<p>
	支持成员关系操作符（in）与尺寸操作符（len()）的数据类型，并且也是可以迭代的（任意顺序提供数据项）。映射是键-值数据项的组合，并提供了存取数据项及键-值的方法。
</p>
<p>
	两种无序的映射：内置的dict类型，以及标准库中的collection。OrderedDict类型。有序的映射类型coolections.OrderedDict（一个字典，与内置的dict具有相同的方法和属性）
</p>
<p>
	只有可哈希运算的对象可用作字典的键。每个键向关联的值实际上是对象引用，可以引用任何类型的对象，包括数字，字符串，列表，集合，字典，函数……。
</p>
<p>
	字典可以使用标准的比较操作符<span>（&lt;, &lt;=, ==, !=, &gt;=, &gt;）进行比较（逐项进行的）（有意义的操作符是==与!=）</span> 
</p>
<h4>
	字典
</h4>
<p>
	dict是一种无序的组合数据类型，是可变的。
</p>
<p>
	dict()作为函数调用。不带参数时返回一个空字典；带一个映射类型的参数时，返回一个字典；也可以使用序列型参数（序列中每个数据项本身是一个包含两个对象的序列）。用花括号创建时，每项包含一个键，一个字面意义的冒号，以及一个值。
</p>
<pre class="prettyprint lang-py">&gt;&gt;&gt; dict({"id":1996,"name":"chen","size":18})      #创建字典的几种方法
{'id': 1996, 'name': 'chen', 'size': 18}
&gt;&gt;&gt; dict(id=1996,name="chen",size=18)
{'id': 1996, 'name': 'chen', 'size': 18}
&gt;&gt;&gt; dict([("id",1996),("name","chen"),("size",18)])
{'id': 1996, 'name': 'chen', 'size': 18}
&gt;&gt;&gt; dict(zip(("id","name","size"),(1996,"chen",18)))
{'id': 1996, 'name': 'chen', 'size': 18}
&gt;&gt;&gt; {"id":1996,"name":"chen","size":18}
{'id': 1996, 'name': 'chen', 'size': 18}
&gt;&gt;&gt; dict(zip(("id","name","size"),(1996,"chen",18)))["name"]
'chen'
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; d=dict(zip(("id","name","size"),(1996,"chen",18)))      #添加键-值
&gt;&gt;&gt; d["new"]="success"
&gt;&gt;&gt; d
{'id': 1996, 'name': 'chen', 'size': 18, 'new': 'success'}
&gt;&gt;&gt; del d["size"]      #删除键-值对
&gt;&gt;&gt; d
{'id': 1996, 'name': 'chen', 'new': 'success'}</pre>
<h4>
	字典内涵
</h4>
<p>
	{keyexpression: valueexpression for key, value in iterable if condition}&nbsp; &nbsp; 带有一个可选条件的循环。创建反转的字典d_new={v:k for k,v in d.items()}
</p>
<h4>
	默认字典
</h4>
<p>
	存取一个字典时如果发现没有需要的键就自动创建一个，不会产生KeyError异常。
</p>
<p>
	words=collections.defaultdict(int)。创建一个默认字典，当存取不存在的键是，创建一个值为0的键（通过int()）。使用前需要引入collections模块。
</p>
<h4>
	有序字典
</h4>
<pre class="prettyprint lang-py">&gt;&gt;&gt; d=collections.OrderedDict([('z',-4),('e',19),('k',7)])
&gt;&gt;&gt; d
OrderedDict([('z', -4), ('e', 19), ('k', 7)])
&gt;&gt;&gt; task=collections.OrderedDict()
&gt;&gt;&gt; task[12]="qw"
&gt;&gt;&gt; task[34]="as"
&gt;&gt;&gt; task[56]="zx"
&gt;&gt;&gt; task
OrderedDict([(12, 'qw'), (34, 'as'), (56, 'zx')])
&gt;&gt;&gt; list(task.keys())      #可以顺序输出列表
[12, 34, 56]</pre>
可以通过d=collections.OrderedDict(sorted(d.items())) 转换为排序字典。插入任何键将被插入到尾部。</div>
      <!-- 
      <p class="diggit">
        <a href="JavaScript:makeRequest('/e/public/digg/?classid=3&amp;id=19&amp;dotop=1&amp;doajax=1&amp;ajaxarea=diggnum','EchoReturnedText','GET','');"> 很赞哦！ </a>(<b id="diggnum"><script type="text/javascript" src="/e/public/ViewClick/?classid=2&amp;id=20&amp;down=5"></script>13</b>)
      </p>
       -->

    </div>
    
    <div class="nextinfo">
      
        
        
            <p>上一篇：<a href="/p/856.html">Python数据类型</a></p>
        
        
      
      
        
        
            <p>下一篇：<a href="/p/858.html">Python控制结构与异常处理</a></p>
        
      
    </div>
    
    <!-- 转载声明 -->
    
	
	<div><!-- 添加新的评论 -->
		
   
		
		<div class="news_pl">
		    <h2>文章评论</h2>	
		  	
				<ul>
					<div class="gbko">
						<span id="">
							<h2 style="display:inline;color:#5BC648;"></h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-02-22&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><p>
	del语句并不一定是删除数据，应用于某些对象引用（引用的是非组合类型的数据项）时，del语句是取消该对象引用到数据项的绑定，并删除对象引用。
</p>
<p>
	<br />
</p>
<pre class="prettyprint lang-py">&gt;&gt;&gt; x=2312
&gt;&gt;&gt; x
2312
&gt;&gt;&gt; del x
&gt;&gt;&gt; x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'x' is not defined</pre>
<p>
	<br />
</p></span><!-- 内容 -->
					</div>
	      		</ul>
			
				<ul>
					<div class="gbko">
						<span id="">
							<h2 style="display:inline;color:#5BC648;"></h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-02-24&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><h3>
	列表方法，函数
</h3>
列表操作常用操作包含以下方法:<br />
<ul>
	<li>
		list.append(obj)：在列表末尾添加新的对象
	</li>
	<li>
		list.count(obj)：统计某个元素在列表中出现的次数
	</li>
	<li>
		list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
	</li>
	<li>
		list.index(obj)：从列表中找出某个值第一个匹配项的索引位置
	</li>
	<li>
		list.insert(index, obj)：将对象插入列表
	</li>
	<li>
		list.pop(obj=list[-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
	</li>
	<li>
		list.remove(obj)：移除列表中某个值的第一个匹配项
	</li>
	<li>
		list.reverse()：反向列表中元素
	</li>
	<li>
		list.sort([func])：对原列表进行排序
	</li>
</ul>
列表操作包含以下函数:<br />
<ul>
	<li>
		cmp(list1, list2)：比较两个列表的元素 (python3已丢弃)
	</li>
	<li>
		len(list)：列表元素个数&nbsp;
	</li>
	<li>
		max(list)：返回列表元素最大值&nbsp;
	</li>
	<li>
		min(list)：返回列表元素最小值&nbsp;
	</li>
	<li>
		list(seq)：将元组转换为列表&nbsp;
	</li>
</ul></span><!-- 内容 -->
					</div>
	      		</ul>
			
				<ul>
					<div class="gbko">
						<span id="">
							<h2 style="display:inline;color:#5BC648;"></h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-02-24&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><h3>
	集合方法与操作符
</h3>
<p>
	hash(s)&nbsp; &nbsp; #返回 s 的 hash 值
</p>
<p>
	基本操作：
</p>
<pre class="prettyprint lang-py">t.add('x')            # 添加一项
s.update([10,37,42])     # 在s中添加多项
t.remove('H')      #使用remove()可以删除一项：
len(s)      #set 的长度
x in s      #测试 x 是否是 s 的成员
x not in s      #测试 x 是否不是 s 的成员
s.issubset(t)
s &lt;= t      #测试是否 s 中的每一个元素都在 t 中
s.issuperset(t)
s &gt;= t      #测试是否 t 中的每一个元素都在 s 中
s.union(t)
s | t      #返回一个新的 set 包含 s 和 t 中的每一个元素
s.intersection(t)
s &amp; t      #返回一个新的 set 包含 s 和 t 中的公共元素
s.difference(t)
s - t      #返回一个新的 set 包含 s 中有但是 t 中没有的元素
s.symmetric_difference(t)
s ^ t      #返回一个新的 set 包含 s 和 t 中不重复的元素
s.copy()      #返回 set “s”的一个浅复制</pre>
<p>
	基本操作
</p>
<pre class="prettyprint lang-py">s.update(t)
s |= t      #返回增加了 set “t”中元素后的 set “s”
s.intersection_update(t)
s &amp;= t      #返回只保留含有 set “t”中元素的 set “s”
s.difference_update(t)
s -= t      #返回删除了 set “t”中含有的元素后的 set “s”
s.symmetric_difference_update(t)
s ^= t      #返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”
s.add(x)      #向 set “s”中增加元素 x
s.remove(x)      #从 set “s”中删除元素 x, 如果不存在则引发 KeyError
s.discard(x)      #如果在 set “s”中存在元素 x, 则删除
s.pop()      #删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError
s.clear()      #删除 set “s”中的所有元素</pre></span><!-- 内容 -->
					</div>
	      		</ul>
			
				<ul>
					<div class="gbko">
						<span id="">
							<h2 style="display:inline;color:#5BC648;"></h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-02-24&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><h3>
	字典方法
</h3>
<p>
	Python字典包含了以下内置函数：
</p>
<table border="1" bordercolor="#000000" cellspacing="0">
	<tbody>
		<tr>
			<th>
				序号
			</th>
			<th>
				函数及描述
			</th>
		</tr>
		<tr>
			<td>
				1
			</td>
			<td>
				cmp(dict1, dict2)<br />
比较两个字典元素。
			</td>
		</tr>
		<tr>
			<td>
				2
			</td>
			<td>
				len(dict)<br />
计算字典元素个数，即键的总数。
			</td>
		</tr>
		<tr>
			<td>
				3
			</td>
			<td>
				str(dict)<br />
输出字典可打印的字符串表示。
			</td>
		</tr>
		<tr>
			<td>
				4
			</td>
			<td>
				type(variable)<br />
返回输入的变量类型，如果变量是字典就返回字典类型。
			</td>
		</tr>
	</tbody>
</table>
<p>
	Python字典包含了以下内置方法：
</p>
<table border="1" bordercolor="#000000" cellspacing="0">
	<tbody>
		<tr>
			<th>
				序号
			</th>
			<th>
				函数及描述
			</th>
		</tr>
		<tr>
			<td>
				1
			</td>
			<td>
				dict.clear()<br />
删除字典内所有元素
			</td>
		</tr>
		<tr>
			<td>
				2
			</td>
			<td>
				dict.copy()<br />
返回一个字典的浅复制
			</td>
		</tr>
		<tr>
			<td>
				3
			</td>
			<td>
				dict.fromkeys(seq[, val])<br />
创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值
			</td>
		</tr>
		<tr>
			<td>
				4
			</td>
			<td>
				dict.get(key, default=None)<br />
返回指定键的值，如果值不在字典中返回default值
			</td>
		</tr>
		<tr>
			<td>
				5
			</td>
			<td>
				dict.has_key(key)<br />
如果键在字典dict里返回true，否则返回false
			</td>
		</tr>
		<tr>
			<td>
				6
			</td>
			<td>
				dict.items()<br />
以列表返回可遍历的(键, 值) 元组数组
			</td>
		</tr>
		<tr>
			<td>
				7
			</td>
			<td>
				dict.keys()<br />
以列表返回一个字典所有的键
			</td>
		</tr>
		<tr>
			<td>
				8
			</td>
			<td>
				dict.setdefault(key, default=None)<br />
和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
			</td>
		</tr>
		<tr>
			<td>
				9
			</td>
			<td>
				dict.update(dict2)<br />
把字典dict2的键/值对更新到dict里
			</td>
		</tr>
		<tr>
			<td>
				10
			</td>
			<td>
				dict.values()<br />
以列表返回字典中的所有值
			</td>
		</tr>
		<tr>
			<td>
				11
			</td>
			<td>
				pop(key[,default])<br />
删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。
			</td>
		</tr>
		<tr>
			<td>
				12
			</td>
			<td>
				popitem()<br />
随机返回并删除字典中的一对键和值。
			</td>
		</tr>
	</tbody>
</table></span><!-- 内容 -->
					</div>
	      		</ul>
			
				<ul>
					<div class="gbko">
						<span id="">
							<h2 style="display:inline;color:#5BC648;"></h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-02-24&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><h3>
	组合数据类型的迭代与复制
</h3>
<p>
	iterable数据类型（任意包含__iter__()方法的对象或任意序列【包含__getitem()方法的对象，该方法接受从0开始的整数参数】都是一个iterable）每次返回其中的一个数据项。可以提供一个迭代子，迭代子是一个对象，可以提供__next__()方法，该方法依此返回每个相继的数据项，并在没数据时返回StopIteration异常。
</p>
<p>
	常见的迭代操作符与函数：
</p>
<p>
	<table cellpadding="1" cellspacing="0" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td>
					语法
				</td>
				<td>
					描述
				</td>
			</tr>
			<tr>
				<td>
					s+t
				</td>
				<td>
					返回一个由序列s和序列t连接的序列
				</td>
			</tr>
			<tr>
				<td>
					s*n
				</td>
				<td>
					返回一个序列s的n个副本连接的序列
				</td>
			</tr>
			<tr>
				<td>
					x in i
				</td>
				<td>
					如果项x出现在iterable i中，就返回True。not in相反
				</td>
			</tr>
			<tr>
				<td>
					all(i)
				</td>
				<td>
					如果iterable中每一项都为True，就返回True
				</td>
			</tr>
			<tr>
				<td>
					any(i)
				</td>
				<td>
					<span>如果iterable中任意一项都为True，就返回True</span><br />
				</td>
			</tr>
			<tr>
				<td>
					enumerate(i, start)
				</td>
				<td>
					常用于for……in循环中，提供一个(index, item)元组序列，其中索引值为0或start。
				</td>
			</tr>
			<tr>
				<td>
					lex(x)
				</td>
				<td>
					返回x的长度，对组合数据类型就是项数。
				</td>
			</tr>
			<tr>
				<td>
					max(i, key)
				</td>
				<td>
					返回iterable i中的最大项，若给定函数就返回key(item)值的最大项
				</td>
			</tr>
			<tr>
				<td>
					min(i, key)
				</td>
				<td>
					与max类似
				</td>
			</tr>
			<tr>
				<td>
					range(start, stop, step)
				</td>
				<td>
					返回一个整数迭代子。迭代子范围为start（含）到stop（不含）每两个值间隔step。
				</td>
			</tr>
			<tr>
				<td>
					reversed(i)
				</td>
				<td>
					返回一个迭代子，以反序从迭代子i中返回项。
				</td>
			</tr>
			<tr>
				<td>
					sorted(i, key, reverse)
				</td>
				<td>
					以排序后顺序从迭代子i返回项，key提供DSU（修饰，排序，返修饰）排序，如果reverse为True，则排序以反序进行。
				</td>
			</tr>
			<tr>
				<td>
					sum(i, start)
				</td>
				<td>
					返回iterable i中各项的和，加上start（默认为0）。i可以包含字符串
				</td>
			</tr>
			<tr>
				<td>
					zip(i1,……iN)
				</td>
				<td>
					返回元组的迭代子，使用迭代子i1到iN。
				</td>
			</tr>
		</tbody>
	</table>
<br />
key相当于传递一个函数参数。
</p>
<p>
	sys.exit()函数可以实现立即的，干净的终止操作，关闭任何打开文件。该函数接受一个可选的int参数，并将该参数传递给调用的shell。
</p>
<p>
	*操作符可以对iterable进行拆分。返回的是iterable的每一项。
</p>
<p>
	zip()函数可以将来自两个或多个列表的数据项进行组合，以一个或多个iterable为参数，返回一个迭代子（元组）。第一个返回的元组存放的是来自每一个iterable的第一个数据项。只要某个iterable中元素用完就终止。
</p>
<h4>
	组合数据类型的复制
</h4>
<ul>
	<li>
		赋值操作符（=）：设置一个对象引用。
	</li>
	<li>
		复制函数dict.copy(), set.copy()与copy模块提供的copy.copy()函数返回给定对象的一个副本。对内置数据类型，可以将待复制的组合类型数据作为参数（dict(d), set(d), list(d)）。这些复制技术都是浅拷贝。
	</li>
	<li>
		copy模块的copy.deepcopy(x)可以提供深拷贝。
	</li>
</ul>
<p>
	对于浅拷贝和深拷贝。对于嵌套类型数据（比如：[3,[2,4],6]）浅拷贝对[2,4]仅是复制的一个引用，而对于深拷贝来说是完全复制的。
</p>
<pre class="prettyprint lang-py">&gt;&gt;&gt; import copy
&gt;&gt;&gt; d=[3,[2,4],6]
&gt;&gt;&gt; fcopy=d      #仅复制了对象引用
&gt;&gt;&gt; scopy=d.copy()      #浅拷贝
&gt;&gt;&gt; dcopy=copy.deepcopy(d)      #深拷贝
&gt;&gt;&gt; d[0]=33
&gt;&gt;&gt; d[1][0]=22
&gt;&gt;&gt; d
[33, [22, 4], 6]
&gt;&gt;&gt; fcopy
[33, [22, 4], 6]
&gt;&gt;&gt; scopy
[3, [22, 4], 6]
&gt;&gt;&gt; dcopy
[3, [2, 4], 6]</pre></span><!-- 内容 -->
					</div>
	      		</ul>
			
		</div>
	
	</div>

 
 		
	</div>

</div>

<div class="blank"></div>

	<div  style="position: fixed;display: float;top: 2px;right: 2px;width: 200px;"><!-- 评论部分 -->

		<!---->
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#序列类型">序列类型</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#集合类型">集合类型</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#映射类型">映射类型</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
		
	
		评论列表
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
	</div>

	<link href="/extends/kindeditor-4.1.10/plugins/code/prettify.css" rel="stylesheet" type="text/css"></script>
	<script charset="utf-8" src="/extends/kindeditor-4.1.10/plugins/code/prettify.js"></script>
	<script type="text/javascript">
	prettyPrint();
	</script>

<!-- 显示访问记录 -->

	<footer>
		<!-- 底部居中的 -->
		<p>Copyright © <a href="http://comonly.cn/" target="_blank">comonly.cn</a> </p>
		<p>备案号：<a href="http://www.miitbeian.gov.cn/">鄂ICP备16003690号-3</a></p>
		<div class="cnzz_bot">
			<style>
			.cnzz_bot img{
			    margin:0 auto;
			}
			</style>
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277884732'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277884732%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
		</div>
	</footer>

 
</body>
</html>
