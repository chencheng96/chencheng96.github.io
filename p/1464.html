






<!doctype html>
<html>
<head>
<title>C++ Primer Plus(第6版)中文版【目录】_comonly.cn</title>
<meta name="keywords" content="C++ Primer Plus(第6版)中文版【目录】" />
<meta name="description" content="一本经久不衰的C 畅销经典教程；首本支持C 11新标准的程序设计图书。

它被誉为“开发人员学习C 的必备教程，没有之一”！ 网站“Language”类销售排名第三的超级畅销书，之前版本在美国销售超10万！

《C Primer Plus(第6版)中文版》可以说是一本面向从未学习过C语言甚至是从未学习过编程的人的入门书籍，它的首章从基础内容讲起，先介绍了传统编程的规则，后面才着重讲解有关面向对象——C 的精髓之一——的有关内容。整个书的结构安排较为合理，难度爬升较慢。

如果你是一个从未学过C" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="/css/css_yangqingqing.css" rel="stylesheet">
</head>
<body>
<div class="box">
 <div class="blank"></div>
 <div class="infosbox">
    <div class="newsview">
      <h3 class="news_title">C++ Primer Plus(第6版)中文版【目录】</h3>
      <div class="bloginfo">
        <ul>
          <li class="author"></li>
          <li class="lmname"><a href="" target="_blank"></a></li>
          <li class="timer">2019-09-18</li>
          	
         
          
          <!-- origin -->
		  <li class="view">
 

	程序简版
 	  	
		  </li>		  
		  <li class="view">公开</li>

 
          <!-- 
          <li class="view">4567已阅读</li>
          <li class="like">8888888</li>
           -->
        </ul>
      </div>
      
      
        <div class="news_about"><strong>简介</strong>一本经久不衰的C 畅销经典教程；首本支持C 11新标准的程序设计图书。

它被誉为“开发人员学习C 的必备教程，没有之一”！ 网站“Language”类销售排名第三的超级畅销书，之前版本在美国销售超10万！

《C Primer Plus(第6版)中文版》可以说是一本面向从未学习过C语言甚至是从未学习过编程的人的入门书籍，它的首章从基础内容讲起，先介绍了传统编程的规则，后面才着重讲解有关面向对象——C 的精髓之一——的有关内容。整个书的结构安排较为合理，难度爬升较慢。

如果你是一个从未学过C</div>
      
      <!-- <div class="news_con"> -->
      <div class="realContent_kindeditor"> 一本经久不衰的C 畅销经典教程；首本支持C 11新标准的程序设计图书。<br />
<br />
它被誉为“开发人员学习C 的必备教程，没有之一”！ 网站“Language”类销售排名第三的超级畅销书，之前版本在美国销售超10万！<br />
<br />
《C Primer Plus(第6版)中文版》可以说是一本面向从未学习过C语言甚至是从未学习过编程的人的入门书籍，它的首章从基础内容讲起，先介绍了传统编程的规则，后面才着重讲解有关面向对象——C 的精髓之一——的有关内容。整个书的结构安排较为合理，难度爬升较慢。<br />
<br />
如果你是一个从未学过C语言（或者压根没学会C）的读者，那么，我相信这本书更适合你。<br />
<br />
内容提要<br />
<br />
C 是在 C 语言基础上开发的一种集面向对象编程、泛型编程和过程化编程于一体的编程语言，是C语言的超集。《C Primer Plus(第6版)中文版》是根据2003年的ISO/ANSI C 标准编写的，通过大量短小精悍的程序详细而全面地阐述了 C 的基本概念和技术，并专辟一章介绍了C 11新增的功能。<br />
<br />
全书分18章和10个附录。分别介绍了C 程序的运行方式、基本数据类型、复合数据类型、循环和关系表达式、分支语句和逻辑运算符、函数重载和函数模板、内存模型和名称空间、类的设计和使用、多态、虚函数、动态内存分配、继承、代码重用、友元、异常处理技术、string类和标准模板库、输入/输出、C 11新增功能等内容。<br />
<br />
《C Primer Plus(第6版)中文版》针对C 初学者，书中从C语言基础知识开始介绍，然后在此基础上详细阐述C 新增的特性，因此不要求读者有C语言方面的背景知识。本书可作为高等院校教授C 课程的教材，也可供初学者自学C 时使用。<br />
<br />
目录<br />
<br />
<br />
<br />
第1章 预备知识 1<br />
1.1 C 简介 1<br />
1.2 C 简史 2<br />
1.2.1 C语言 2<br />
1.2.2 C语言编程原理 2<br />
1.2.3 面向对象编程 3<br />
1.2.4 C 和泛型编程 4<br />
1.2.5 C 的起源 4<br />
1.3 可移植性和标准 5<br />
1.3.1 C 的发展 6<br />
1.3.2 本书遵循的C 标准 6<br />
1.4 程序创建的技巧 6<br />
1.4.1 创建源代码文件 7<br />
1.4.2 编译和链接 8<br />
1.5 总结 10<br />
<br />
第2章 开始学习C 12<br />
2.1 进入C 12<br />
2.1.1 main()函数 13<br />
2.1.2 C 注释 15<br />
2.1.3 C 预处理器和iostream文件 16<br />
2.1.4 头文件名 16<br />
2.1.5 名称空间 17<br />
2.1.6 使用cout进行C 输出 18<br />
2.1.7 C 源代码的格式化 19<br />
2.2 C 语句 21<br />
2.2.1 声明语句和变量 21<br />
2.2.2 赋值语句 22<br />
2.2.3 cout的新花样 23<br />
2.3 其他C 语句 23<br />
2.3.1 使用cin 24<br />
2.3.2 使用cout进行拼接 24<br />
2.3.3 类简介 25<br />
2.4 函数 26<br />
2.4.1 使用有返回值的函数 26<br />
2.4.2 函数变体 29<br />
2.4.3 用户定义的函数 29<br />
2.4.4 用户定义的有返回值的函数 32<br />
2.4.5 在多函数程序中使用using编译指令 33<br />
2.5 总结 34<br />
2.6 复习题 35<br />
2.7 编程练习 35<br />
<br />
第3章 处理数据 37<br />
3.1 简单变量 37<br />
3.1.1 变量名 38<br />
3.1.2 整型 39<br />
3.1.3 整型short、int、long和long long 39<br />
3.1.4 无符号类型 43<br />
3.1.5 选择整型类型 45<br />
3.1.6 整型字面值 45<br />
3.1.7 C 如何确定常量的类型 47<br />
3.1.8 char类型：字符和小整数 47<br />
3.1.9 bool类型 53<br />
3.2 const限定符 54<br />
3.3 浮点数 55<br />
3.3.1 书写浮点数 55<br />
3.3.2 浮点类型 56<br />
3.3.3 浮点常量 58<br />
3.3.4 浮点数的优缺点 58<br />
3.4 C 算术运算符 59<br />
3.4.1 运算符优先级和结合性 60<br />
3.4.2 除法分支 60<br />
3.4.3 求模运算符 61<br />
3.4.4 类型转换 62<br />
3.4.5 C 11中的auto声明 66<br />
3.5 总结 67<br />
3.6 复习题 67<br />
3.7 编程练习 68<br />
<br />
第4章 复合类型 70<br />
4.1 数组 70<br />
4.1.1 程序说明 72<br />
4.1.2 数组的初始化规则 73<br />
4.1.3 C 11数组初始化方法 73<br />
4.2 字符串 74<br />
4.2.1 拼接字符串常量 75<br />
4.2.2 在数组中使用字符串 76<br />
4.2.3 字符串输入 77<br />
4.2.4 每次读取一行字符串输入 78<br />
4.2.5 混合输入字符串和数字 81<br />
4.3 string类简介 82<br />
4.3.1 C 11字符串初始化 83<br />
4.3.2 赋值、拼接和附加 83<br />
4.3.3 string类的其他操作 84<br />
4.3.4 string类I/O 86<br />
4.3.5 其他形式的字符串字面值 87<br />
4.4 结构简介 88<br />
4.4.1 在程序中使用结构 89<br />
4.4.2 C 11结构初始化 91<br />
4.4.3 结构可以将string类作为成员吗 91<br />
4.4.4 其他结构属性 91<br />
4.4.5 结构数组 93<br />
4.4.6 结构中的位字段 94<br />
4.5 共用体 94<br />
4.6 枚举 95<br />
4.6.1 设置枚举量的值 97<br />
4.6.2 枚举的取值范围 97<br />
4.7 指针和自由存储空间 97<br />
4.7.1 声明和初始化指针 100<br />
4.7.2 指针的危险 101<br />
4.7.3 指针和数字 102<br />
4.7.4 使用new来分配内存 102<br />
4.7.5 使用delete释放内存 104<br />
4.7.6 使用new来创建动态数组 104<br />
4.8 指针、数组和指针算术 106<br />
4.8.1 程序说明 107<br />
4.8.2 指针小结 109<br />
4.8.3 指针和字符串 111<br />
4.8.4 使用new创建动态结构 114<br />
4.8.5 自动存储、静态存储和动态存储 117<br />
4.9 类型组合 118<br />
4.10 数组的替代品 120<br />
4.10.1 模板类vector 120<br />
4.10.2 模板类array(C 11) 120<br />
4.10.3 比较数组、vector对象和array对象 120<br />
4.11 总结 122<br />
4.12 复习题 123<br />
4.13 编程练习 123<br />
<br />
第5章 循环和关系表达式 125<br />
5.1 for循环 125<br />
5.1.1 for循环的组成部分 126<br />
5.1.2 回到for循环 131<br />
5.1.3 修改步长 132<br />
5.1.4 使用for循环访问字符串 133<br />
5.1.5 递增运算符( )和递减运算符(--) 133<br />
5.1.6 副作用和顺序点 134<br />
5.1.7 前缀格式和后缀格式 135<br />
5.1.8 递增/递减运算符和指针 135<br />
5.1.9 组合赋值运算符 136<br />
5.1.10 复合语句(语句块) 136<br />
5.1.11 其他语法技巧——逗号运算符 138<br />
5.1.12 关系表达式 140<br />
5.1.13 赋值、比较和可能犯的错误 141<br />
5.1.14 C-风格字符串的比较 142<br />
5.1.15 比较string类字符串 144<br />
5.2 while循环 145<br />
5.2.1 for与while 147<br />
5.2.2 等待一段时间：编写延时循环 148<br />
5.3 do while循环 150<br />
5.4 基于范围的for循环(C 11) 152<br />
5.5 循环和文本输入 152<br />
5.5.1 使用原始的cin进行输入 152<br />
5.5.2 使用cin.get(char)进行补救 153<br />
5.5.3 使用哪一个cin.get() 154<br />
5.5.4 文件尾条件 155<br />
5.5.5 另一个cin.get()版本 157<br />
5.6 嵌套循环和二维数组 159<br />
5.6.1 初始化二维数组 160<br />
5.6.2 使用二维数组 160<br />
5.7 总结 162<br />
5.8 复习题 163<br />
5.9 编程练习 163<br />
<br />
第6章 分支语句和逻辑运算符 165<br />
6.1 if语句 165<br />
6.1.1 if else语句 167<br />
6.1.2 格式化if else语句 168<br />
6.1.3 if else if else结构 169<br />
6.2 逻辑表达式 170<br />
6.2.1 逻辑OR运算符：|| 171<br />
6.2.2 逻辑AND运算符：&amp;&amp; 172<br />
6.2.3 用&amp;&amp;来设置取值范围 174<br />
6.2.4 逻辑NOT运算符：! 175<br />
6.2.5 逻辑运算符细节 176<br />
6.2.6 其他表示方式 177<br />
6.3 字符函数库cctype 177<br />
6.4 ?:运算符 179<br />
6.5 switch语句 180<br />
6.5.1 将枚举量用作标签 183<br />
6.5.2 switch和if else 184<br />
6.6 break和continue语句 185<br />
6.7 读取数字的循环 187<br />
6.8 简单文件输入/输出 190<br />
6.8.1 文本I/O和文本文件 190<br />
6.8.2 写入到文本文件中 191<br />
6.8.3 读取文本文件 194<br />
6.9 总结 197<br />
6.10 复习题 198<br />
6.11 编程练习 199<br />
<br />
第7章 函数——C 的编程模块 202<br />
7.1 复习函数的基本知识 202<br />
7.1.1 定义函数 203<br />
7.1.2 函数原型和函数调用 205<br />
7.2 函数参数和按值传递 207<br />
7.2.1 多个参数 208<br />
7.2.2 另外一个接受两个参数的函数 210<br />
7.3 函数和数组 212<br />
7.3.1 函数如何使用指针来处理数组 213<br />
7.3.2 将数组作为参数意味着什么 213<br />
7.3.3 更多数组函数示例 215<br />
7.3.4 使用数组区间的函数 220<br />
7.3.5 指针和const 221<br />
7.4 函数和二维数组 224<br />
7.5 函数和C-风格字符串 225<br />
7.5.1 将C-风格字符串作为参数的函数 225<br />
7.5.2 返回C-风格字符串的函数 227<br />
7.6 函数和结构 228<br />
7.6.1 传递和返回结构 228<br />
7.6.2 另一个处理结构的函数示例 230<br />
7.6.3 传递结构的地址 234<br />
7.7 函数和string对象 235<br />
7.8 函数与array对象 236<br />
7.9 递归 238<br />
7.9.1 包含一个递归调用的递归 239<br />
7.9.2 包含多个递归调用的递归 240<br />
7.10 函数指针 241<br />
7.10.1 函数指针的基础知识 241<br />
7.10.2 函数指针示例 243<br />
7.10.3 深入探讨函数指针 244<br />
7.10.4 使用typedef进行简化 248<br />
7.11 总结 248<br />
7.12 复习题 249<br />
7.13 编程练习 250<br />
<br />
第8章 函数探幽 253<br />
8.1 C 内联函数 253<br />
8.2 引用变量 255<br />
8.2.1 创建引用变量 256<br />
8.2.2 将引用用作函数参数 258<br />
8.2.3 引用的属性和特别之处 260<br />
8.2.4 将引用用于结构 263<br />
8.2.5 将引用用于类对象 268<br />
8.2.6 对象、继承和引用 271<br />
8.2.7 何时使用引用参数 274<br />
8.3 默认参数 274<br />
8.4 函数重载 276<br />
8.4.1 重载示例 278<br />
8.4.2 何时使用函数重载 280<br />
8.5 函数模板 281<br />
8.5.1 重载的模板 283<br />
8.5.2 模板的局限性 285<br />
8.5.3 显式具体化 285<br />
8.5.4 实例化和具体化 288<br />
8.5.5 编译器选择使用哪个函数版本 289<br />
8.5.6 模板函数的发展 295<br />
8.6 总结 297<br />
8.7 复习题 297<br />
8.8 编程练习 298<br />
<br />
第9章 内存模型和名称空间 300<br />
9.1 单独编译 300<br />
9.2 存储持续性、作用域和链接性 304<br />
9.2.1 作用域和链接 305<br />
9.2.2 自动存储持续性 305<br />
9.2.3 静态持续变量 309<br />
9.2.4 静态持续性、外部链接性 310<br />
9.2.5 静态持续性、内部链接性 313<br />
9.2.6 静态存储持续性、无链接性 315<br />
9.2.7 说明符和限定符 317<br />
9.2.8 函数和链接性 318<br />
9.2.9 语言链接性 319<br />
9.2.10 存储方案和动态分配 319<br />
9.3 名称空间 324<br />
9.3.1 传统的C 名称空间 324<br />
9.3.2 新的名称空间特性 325<br />
9.3.3 名称空间示例 331<br />
9.3.4 名称空间及其前途 334<br />
9.4 总结 335<br />
9.5 复习题 335<br />
9.6 编程练习 338<br />
<br />
第10章 对象和类 340<br />
10.1 过程性编程和面向对象编程 340<br />
10.2 抽象和类 341<br />
10.2.1 类型是什么 341<br />
10.2.2 C 中的类 342<br />
10.2.3 实现类成员函数 345<br />
10.2.4 使用类 349<br />
10.2.5 修改实现 350<br />
10.2.6 小结 351<br />
10.3 类的构造函数和析构函数 352<br />
10.3.1 声明和定义构造函数 353<br />
10.3.2 使用构造函数 354<br />
10.3.3 默认构造函数 354<br />
10.3.4 析构函数 355<br />
10.3.5 改进Stock类 356<br />
10.3.6 构造函数和析构函数小结 362<br />
10.4 this指针 363<br />
10.5 对象数组 368<br />
10.6 类作用域 370<br />
10.6.1 作用域为类的常量 371<br />
10.6.2 作用域内枚举(C 11) 372<br />
10.7 抽象数据类型 373<br />
10.8 总结 376<br />
10.9 复习题 377<br />
10.10 编程练习 377<br />
<br />
第11章 使用类 380<br />
11.1 运算符重载 380<br />
11.2 计算时间：一个运算符重载示例 381<br />
11.2.1 添加加法运算符 384<br />
11.2.2 重载限制 387<br />
11.2.3 其他重载运算符 388<br />
11.3 友元 390<br />
11.3.1 创建友元 391<br />
11.3.2 常用的友元：重载&lt;&lt;运算符 392<br />
11.4 重载运算符：作为成员函数还是非成员函数 397<br />
11.5 再谈重载：一个矢量类 398<br />
11.5.1 使用状态成员 404<br />
11.5.2 为Vector类重载算术运算符 406<br />
11.5.3 对实现的说明 408<br />
11.5.4 使用Vector类来模拟随机漫步 408<br />
11.6 类的自动转换和强制类型转换 411<br />
11.6.1 转换函数 415<br />
11.6.2 转换函数和友元函数 419<br />
11.7 总结 421<br />
11.8 复习题 422<br />
11.9 编程练习 422<br />
<br />
第12章 类和动态内存分配 425<br />
12.1 动态内存和类 425<br />
12.1.1 复习示例和静态类成员 425<br />
12.1.2 特殊成员函数 432<br />
12.1.3 回到Stringbad：复制构造函数的哪里出了问题 434<br />
12.1.4 Stringbad的其他问题：赋值运算符 436<br />
12.2 改进后的新String类 437<br />
12.2.1 修订后的默认构造函数 438<br />
12.2.2 比较成员函数 439<br />
12.2.3 使用中括号表示法访问字符 439<br />
12.2.4 静态类成员函数 441<br />
12.2.5 进一步重载赋值运算符 441<br />
12.3 在构造函数中使用new时应注意的事项 446<br />
12.3.1 应该和不应该 447<br />
12.3.2 包含类成员的类的逐成员复制 448<br />
12.4 有关返回对象的说明 449<br />
12.4.1 返回指向const对象的引用 449<br />
12.4.2 返回指向非const对象的引用 449<br />
12.4.3 返回对象 450<br />
12.4.4 返回const对象 450<br />
12.5 使用指向对象的指针 451<br />
12.5.1 再谈new和delete 453<br />
12.5.2 指针和对象小结 454<br />
12.5.3 再谈定位new运算符 456<br />
12.6 复习各种技术 459<br />
12.6.1 重载&lt;&lt;运算符 459<br />
12.6.2 转换函数 460<br />
12.6.3 其构造函数使用new的类 460<br />
12.7 队列模拟 460<br />
12.7.1 队列类 461<br />
12.7.2 Customer类 468<br />
12.7.3 ATM模拟 471<br />
12.8 总结 475<br />
12.9 复习题 476<br />
12.10 编程练习 477<br />
<br />
第13章 类继承 480<br />
13.1 一个简单的基类 481<br />
13.1.1 派生一个类 482<br />
13.1.2 构造函数：访问权限的考虑 484<br />
13.1.3 使用派生类 486<br />
13.1.4 派生类和基类之间的特殊关系 488<br />
13.2 继承：is-a关系 489<br />
13.3 多态公有继承 490<br />
13.4 静态联编和动态联编 501<br />
13.4.1 指针和引用类型的兼容性 502<br />
13.4.2 虚成员函数和动态联编 503<br />
13.4.3 有关虚函数注意事项 505<br />
13.5 访问控制：protected 507<br />
13.6 抽象基类 508<br />
13.6.1 应用ABC概念 510<br />
13.6.2 ABC理念 516<br />
13.7 继承和动态内存分配 516<br />
13.7.1 种情况：派生类不使用new 516<br />
13.7.2 第二种情况：派生类使用new 517<br />
13.7.3 使用动态内存分配和友元的继承示例 519<br />
13.8 类设计回顾 523<br />
13.8.1 编译器生成的成员函数 523<br />
13.8.2 其他的类方法 524<br />
13.8.3 公有继承的考虑因素 527<br />
13.8.4 类函数小结 530<br />
13.9 总结 530<br />
13.10 复习题 531<br />
13.11 编程练习 531<br />
<br />
第14章 C 中的代码重用 534<br />
14.1 包含对象成员的类 534<br />
14.1.1 valarray类简介 535<br />
14.1.2 Student类的设计 535<br />
14.1.3 Student类示例 537<br />
14.2 私有继承 543<br />
14.2.1 Student类示例(新版本) 543<br />
14.2.2 使用包含还是私有继承 549<br />
14.2.3 保护继承 549<br />
14.2.4 使用using重新定义访问权限 550<br />
14.3 多重继承 551<br />
14.3.1 有多少Worker 555<br />
14.3.2 哪个方法 558<br />
14.3.3 MI小结 567<br />
14.4 类模板 567<br />
14.4.1 定义类模板 568<br />
14.4.2 使用模板类 570<br />
14.4.3 深入探讨模板类 572<br />
14.4.4 数组模板示例和非类型参数 577<br />
14.4.5 模板多功能性 578<br />
14.4.6 模板的具体化 582<br />
14.4.7 成员模板 584<br />
14.4.8 将模板用作参数 586<br />
14.4.9 模板类和友元 588<br />
14.4.10 模板别名(C 11) 593<br />
14.5 总结 594<br />
14.6 复习题 595<br />
14.7 编程练习 597<br />
<br />
第15章 友元、异常和其他 602<br />
15.1 友元 602<br />
15.1.1 友元类 602<br />
15.1.2 友元成员函数 606<br />
15.1.3 其他友元关系 609<br />
15.1.4 共同的友元 610<br />
15.2 嵌套类 611<br />
15.2.1 嵌套类和访问权限 612<br />
15.2.2 模板中的嵌套 613<br />
15.3 异常 616<br />
15.3.1 调用abort() 616<br />
15.3.2 返回错误码 617<br />
15.3.3 异常机制 619<br />
15.3.4 将对象用作异常类型 621<br />
15.3.5 异常规范和C 11 624<br />
15.3.6 栈解退 625<br />
15.3.7 其他异常特性 629<br />
15.3.8 exception类 631<br />
15.3.9 异常、类和继承 634<br />
15.3.10 异常何时会迷失方向 639<br />
15.3.11 有关异常的注意事项 641<br />
15.4 RTTI 642<br />
15.4.1 RTTI的用途 642<br />
15.4.2 RTTI的工作原理 642<br />
15.5 类型转换运算符 649<br />
15.6 总结 652<br />
15.7 复习题 653<br />
15.8 编程练习 654<br />
<br />
第16章 string类和标准模板库 655<br />
16.1 string类 655<br />
16.1.1 构造字符串 655<br />
16.1.2 string类输入 659<br />
16.1.3 使用字符串 661<br />
16.1.4 string还提供了哪些功能 665<br />
16.1.5 字符串种类 666<br />
16.2 智能指针模板类 667<br />
16.2.1 使用智能指针 668<br />
16.2.2 有关智能指针的注意事项 670<br />
16.2.3 unique_ptr为何优于auto_ptr 672<br />
16.2.4 选择智能指针 673<br />
16.3 标准模板库 674<br />
16.3.1 模板类vector 675<br />
16.3.2 可对矢量执行的操作 676<br />
16.3.3 对矢量可执行的其他操作 680<br />
16.3.4 基于范围的for循环(C 11) 684<br />
16.4 泛型编程 684<br />
16.4.1 为何使用迭代器 685<br />
16.4.2 迭代器类型 688<br />
16.4.3 迭代器层次结构 689<br />
16.4.4 概念、改进和模型 690<br />
16.4.5 容器种类 695<br />
16.4.4 关联容器 702<br />
16.4.5 无序关联容器(C 11) 707<br />
16.5 函数对象 707<br />
16.5.1 函数符概念 707<br />
16.5.2 预定义的函数符 710<br />
16.5.3 自适应函数符和函数适配器 711<br />
16.6 算法 713<br />
16.6.1 算法组 713<br />
16.6.2 算法的通用特征 714<br />
16.6.3 STL和string类 715<br />
16.6.4 函数和容器方法 716<br />
16.6.5 使用STL 717<br />
16.7 其他库 720<br />
16.7.1 vector、valarray和array 720<br />
16.7.2 模板initializer_list(C 11) 724<br />
16.7.3 使用initializer_list 725<br />
16.8 总结 727<br />
16.9 复习题 728<br />
16.10 编程练习 728<br />
<br />
第17章 输入、输出和文件 731<br />
17.1 C 输入和输出概述 731<br />
17.1.1 流和缓冲区 732<br />
17.1.2 流、缓冲区和iostream文件 733<br />
17.1.3 重定向 735<br />
17.2 使用cout进行输出 736<br />
17.2.1 重载的&lt;&lt;运算符 736<br />
17.2.2 其他ostream方法 738<br />
17.2.3 刷新输出缓冲区 740<br />
17.2.4 用cout进行格式化 741<br />
17.3 使用cin进行输入 753<br />
17.3.1 cin&gt;&gt;如何检查输入 754<br />
17.3.2 流状态 756<br />
17.3.3 其他istream类方法 759<br />
17.3.4 其他istream方法 764<br />
17.4 文件输入和输出 768<br />
17.4.1 简单的文件I/O 768<br />
17.4.2 流状态检查和is_open() 770<br />
17.4.3 打开多个文件 771<br />
17.4.4 命令行处理技术 772<br />
17.4.5 文件模式 773<br />
17.4.6 随机存取 781<br />
17.5 内核格式化 788<br />
17.6 总结 790<br />
17.7 复习题 791<br />
17.8 编程练习 792<br />
<br />
第18章 探讨C 新标准 795<br />
18.1 复习前面介绍过的C 11功能 795<br />
18.1.1 新类型 795<br />
18.8.2 统一的初始化 795<br />
18.1.3 声明 796<br />
18.1.4 智能指针 798<br />
18.1.5 异常规范方面的修改 798<br />
18.1.6 作用域内枚举 799<br />
18.1.7 对类的修改 799<br />
18.1.8 模板和STL方面的修改 800<br />
18.1.9 右值引用 801<br />
18.2 移动语义和右值引用 802<br />
18.2.1 为何需要移动语义 802<br />
18.2.2 一个移动示例 803<br />
18.2.3 移动构造函数解析 808<br />
18.2.4 赋值 809<br />
18.2.5 强制移动 809<br />
18.3 新的类功能 813<br />
18.3.1 特殊的成员函数 813<br />
18.3.2 默认的方法和禁用的方法 814<br />
18.3.3 委托构造函数 815<br />
18.3.4 继承构造函数 815<br />
18.3.5 管理虚方法：override和final 817<br />
18.4 Lambda函数 817<br />
18.4.1 比较函数指针、函数符和Lambda函数 818<br />
18.4.2 为何使用lambda 820<br />
18.5 包装器 822<br />
18.5.1 包装器function及模板的低效性 823<br />
18.5.2 修复问题 825<br />
18.5.3 其他方式 826<br />
18.6 可变参数模板 827<br />
18.6.1 模板和函数参数包 827<br />
18.6.2 展开参数包 828<br />
18.6.3 在可变参数模板函数中使用递归 828<br />
18.7 C 11新增的其他功能 831<br />
18.7.1 并行编程 831<br />
18.7.2 新增的库 831<br />
18.7.3 低级编程 832<br />
18.7.4 杂项 832<br />
18.8 语言变化 832<br />
18.8.1 Boost项目 833<br />
18.8.2 TR1 833<br />
18.8.3 使用Boost 833<br />
18.9 接下来的任务 834<br />
18.10 总结 834<br />
18.11 复习题 835<br />
18.12 编程练习 838<br />
<br />
附录A 计数系统 839<br />
A.1 十进制数 839<br />
A.2 八进制整数 839<br />
A.3 十六进制数 839<br />
A.4 二进制数 840<br />
A.5 二进制和十六进制 841<br />
<br />
附录B C 保留字 842<br />
B.1 C 关键字 842<br />
B.2 替代标记 842<br />
B.3 C 库保留名称 843<br />
B.4 有特殊含义的标识符 843<br />
<br />
附录C ASCII字符集 845<br />
<br />
附录D 运算符优先级 849<br />
<br />
附录E 其他运算符 852<br />
E.1 按位运算符 852<br />
E.1.1 移位运算符 852<br />
E.1.2 逻辑按位运算符 853<br />
E.1.3 按位运算符的替代表示 855<br />
E.1.4 几种常用的按位运算符技术 856<br />
E.2 成员解除引用运算符 857<br />
E.3 alignof(C 11) 860<br />
E.4 noexcept(C 11) 861<br />
<br />
附录F 模板类string 862<br />
F.1 13种类型和一个常量 862<br />
F.2 数据信息、构造函数及其他 863<br />
F.2.1 默认构造函数 865<br />
F.2.2 使用C-风格字符串的构造函数 865<br />
F.2.3 使用部分C-风格字符串的构造函数 865<br />
F.2.4 使用左值引用的构造函数 866<br />
F.2.5 使用右值引用的构造函数(C 11) 866<br />
F.2.6 使用一个字符的n个副本的构造函数 867<br />
F.2.7 使用区间的构造函数 867<br />
F.2.8 使用初始化列表的构造函数(C 11) 868<br />
F.2.9 内存杂记 868<br />
F.3 字符串存取 868<br />
F.4 基本赋值 869<br />
F.5 字符串搜索 869<br />
F.5.1 find()系列 870<br />
F.5.2 rfind()系列 870<br />
F.5.3 find_first_of()系列 870<br />
F.5.4 find_last_of()系列 871<br />
F.5.5 find_first_not_of()系列 871<br />
F.5.6 find_last_not_of()系列 871<br />
F.6 比较方法和函数 872<br />
F.7 字符串修改方法 873<br />
F.7.1 用于追加和相加的方法 873<br />
F.7.2 其他赋值方法 874<br />
F.7.3 插入方法 874<br />
F.7.4 清除方法 875<br />
F.7.5 替换方法 875<br />
F.7.6 其他修改方法：copy()和swap() 876<br />
F.8 输出和输入 876<br />
<br />
附录G 标准模板库方法和函数 877<br />
G.1 STL和C 11 877<br />
G.1.1 新增的容器 877<br />
G.1.2 对C 98容器所做的修改 877<br />
G.2 大部分容器都有的成员 878<br />
G.3 序列容器的其他成员 881<br />
G.4 set和map的其他操作 883<br />
G.4 无序关联容器(C 11) 884<br />
G.5 STL函数 886<br />
G.5.1 非修改式序列操作 886<br />
G.5.2 修改式序列操作 890<br />
G.5.3 排序和相关操作 897<br />
G.5.4 数值运算 907<br />
<br />
附录H 精选读物和网上资源 909<br />
H.1 精选读物 909<br />
H.2 网上资源 910<br />
<br />
附录I 转换为ISO标准C 911<br />
I.1 使用一些预处理器编译指令的替代品 911<br />
I.1.1 使用const而不是#define来定义常量 911<br />
I.1.2 使用inline而不是#define来定义小型函数 912<br />
I.2 使用函数原型 913<br />
I.3 使用类型转换 913<br />
I.4 熟悉C 特性 913<br />
I.5 使用新的头文件 914<br />
I.6 使用名称空间 914<br />
I.7 使用智能指针 915<br />
I.8 使用string类 915<br />
I.9 使用STL 915<br />
<br /></div>
      <!-- 
      <p class="diggit">
        <a href="JavaScript:makeRequest('/e/public/digg/?classid=3&amp;id=19&amp;dotop=1&amp;doajax=1&amp;ajaxarea=diggnum','EchoReturnedText','GET','');"> 很赞哦！ </a>(<b id="diggnum"><script type="text/javascript" src="/e/public/ViewClick/?classid=2&amp;id=20&amp;down=5"></script>13</b>)
      </p>
       -->

    </div>
    
    <div class="nextinfo">
      
        
        
            <p>上一篇：<a href="/p/1463.html">Visual C++游戏开发案例实战【目录】</a></p>
        
        
      
      
        
        
            <p>下一篇：<a href="/p/1465.html">Snipaste电脑截图工具</a></p>
        
      
    </div>
    
    <!-- 转载声明 -->
    
	
	<div><!-- 添加新的评论 -->
		
   
		
		<div class="news_pl">
		    	
		  	
		</div>
	
	</div>

 
 		
	</div>

</div>

<div class="blank"></div>

	<div  style="position: fixed;display: float;top: 2px;right: 2px;width: 200px;"><!-- 评论部分 -->

		<!---->
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
		
	
		
		
	</div>

	<link href="/extends/kindeditor-4.1.10/plugins/code/prettify.css" rel="stylesheet" type="text/css"></script>
	<script charset="utf-8" src="/extends/kindeditor-4.1.10/plugins/code/prettify.js"></script>
	<script type="text/javascript">
	prettyPrint();
	</script>

<!-- 显示访问记录 -->

	<footer>
		<!-- 底部居中的 -->
		<p>Copyright © <a href="http://comonly.cn/" target="_blank">comonly.cn</a> </p>
		<p>备案号：<a href="http://www.miitbeian.gov.cn/">鄂ICP备16003690号-3</a></p>
		<div class="cnzz_bot">
			<style>
			.cnzz_bot img{
			    margin:0 auto;
			}
			</style>
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277884732'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277884732%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
		</div>
	</footer>

 
</body>
</html>
