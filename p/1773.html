






<!doctype html>
<html>
<head>
<title>SOAP详解_comonly.cn</title>
<meta name="keywords" content="SOAP详解" />
<meta name="description" content="1.&nbsp;SOAP简介


	1.1应用背景


	对于应用程序开发来说，使程序之间进行因特网通信是很重要的。目前的应用程序通过使用远程过程调用（RPC）在诸如&nbsp;DCOM&nbsp;与&nbsp;CORBA&nbsp;等对象之间进行通信，但是&nbsp;HTTP&nbsp;不是为此设计的。RPC&nbsp;会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。通过&nbsp;HTTP&nbsp;在应用程序间通信是更好的方法，因为&nbsp;HTTP&nbsp;得到了所" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="/css/css_yangqingqing.css" rel="stylesheet">
</head>
<body>
<div class="box">
 <div class="blank"></div>
 <div class="infosbox">
    <div class="newsview">
      <h3 class="news_title">SOAP详解</h3>
      <div class="bloginfo">
        <ul>
          <li class="author">UniqueColor</li>
          <li class="lmname"><a href="https://www.cnblogs.com/UniqueColor/p/5788906.html" target="_blank">https://www.cnblogs.com/UniqueColor/p/5788906.html</a></li>
          <li class="timer">2020-10-03</li>
          	
         
          
          <!-- origin -->
		  <li class="view">
 

	程序简版
 	  	
		  </li>		  
		  <li class="view">公开</li>

 
          <!-- 
          <li class="view">4567已阅读</li>
          <li class="like">8888888</li>
           -->
        </ul>
      </div>
      
      
        <div class="news_about"><strong>简介</strong>1.&nbsp;SOAP简介


	1.1应用背景


	对于应用程序开发来说，使程序之间进行因特网通信是很重要的。目前的应用程序通过使用远程过程调用（RPC）在诸如&nbsp;DCOM&nbsp;与&nbsp;CORBA&nbsp;等对象之间进行通信，但是&nbsp;HTTP&nbsp;不是为此设计的。RPC&nbsp;会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。通过&nbsp;HTTP&nbsp;在应用程序间通信是更好的方法，因为&nbsp;HTTP&nbsp;得到了所</div>
      
      <!-- <div class="news_con"> -->
      <div class="realContent_kindeditor"> <h2 id='1.&b;SOAP简介'>
	1.&nbsp;SOAP简介
</h2>
<h3>
	<a></a>1.1应用背景
</h3>
<p>
	对于应用程序开发来说，使程序之间进行因特网通信是很重要的。目前的应用程序通过使用远程过程调用（RPC）在诸如&nbsp;DCOM&nbsp;与&nbsp;CORBA&nbsp;等对象之间进行通信，但是&nbsp;HTTP&nbsp;不是为此设计的。RPC&nbsp;会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。通过&nbsp;HTTP&nbsp;在应用程序间通信是更好的方法，因为&nbsp;HTTP&nbsp;得到了所有的因特网浏览器及服务器的支持。SOAP&nbsp;就是被创造出来完成这个任务的。SOAP&nbsp;提供了一种标准的方法，使得运行在不同的操作系统并使用不同的技术和编程语言的应用程序可以互相进行通信。
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>1.2概念定义
</h3>
<p>
	SOAP&nbsp;是基于&nbsp;XML&nbsp;的简易协议，是用在分散或分布的环境中交换信息的简单的协议，可使应用程序在&nbsp;HTTP&nbsp;之上进行信息交换。或者更简单地说：SOAP&nbsp;是用于访问网络服务的协议。包括三个部分：封装定义了一个描述消息中包含什么内容以及如何处理它们的框架，编码规则用于表示应用程序定义的数据类型的实例，另外还有一个表示远程过程调用和应答的协定。SOAP被设计为可以与各种其它协议结合使用；这里仅描述如何将SOAP和HTTP及HTTP扩展框架相结合。&nbsp;
</p>
<p>
	&nbsp;
</p>
<p>
	SOAP以XML形式提供了一个简单、轻量的用于在分散或分布环境中交换结构化和类型化信息的机制。SOAP本身并没有定义任何应用程序语义，如编程模型或特定语义的实现；实际上它通过提供一个有标准组件的包模型和在模块中编码数据的机制，定义了一个简单的表示应用程序语义的机制。这使SOAP能够被用于从消息传递到RPC的各种系统。&nbsp;目前最新版本的SOAP1.2是Sun&nbsp;Microsystems、IBM、BEA、Microsoft和Oracle等供应商领导的W3C&nbsp;XML工作组推出并维护的。
</p>
<p>
	SOAP的两个目标是简单性和可扩展性，这就意味着有一些传统的消息系统或分布式对象系统中的某些性质将不是SOAP规范的一部分。SOAP是一种分布式计算中的技术，它被有意的设计为轻量级的协议，它的某些功能和其他一些机制（如RMI）共有的，但也存在许多不同的功能，如不支持通过引用传递对象、对象激活、消息批处理等。SOAP也被设计成可扩展的，而简单性和可扩展性意味着SOAP的使用不包含任何特定的编程模式，给定实现的语义是极为灵活的。
</p>
<p>
	&nbsp;
</p>
<p>
	SOAP基于XML语言和XSD标准，其定义了一套编码规则，该规则定义如何将数据表示为消息，以及怎样通过HTTP协议来传输SOAP消息，它由以下四部分组成：
</p>
<p>
	&gt;&nbsp;SOAP信封（Envelope）：定义了一个框架，该框架描述了消息中的内容是什么，包括消息的内容、发送者、接收者、处理者以及如何处理这些消息。
</p>
<p>
	&gt;&nbsp;SOAP编码规则：它定义了一种系列化机制，用于交换应用程序所定义的数据类型的实例。
</p>
<p>
	&gt;&nbsp;SOAP&nbsp;RPC表示：它定义了用于表示远程过程调用和应答协定。
</p>
<p>
	&gt;&nbsp;SOAP绑定：它定义了一种使用底层传输协议来完成在节点间交换SOAP信封的约定。
</p>
<p>
	SOAP消息基本上是从发送端到接收端的单向传输，它们常常结合起来执行类似于请求/应答的模式。不需要吧SOAP消息绑定到特定的协议，SOAP可以运行在任何其他传输协议（HTTP、SMTP、FTP等）上。另外，SOAP提供了标准的RPC方法来调用Web&nbsp;Service以请求/响应模式运行。
</p>
<p>
	&nbsp;
</p>
<p>
	注意：
</p>
<p>
	实际上，SOAP在这里有点用词不当：它意味着下面的Web&nbsp;service是以对象的方式表示的，但事实并不一定如此：你完全可以把你的Web&nbsp;service写成一系列的C函数，并仍然使用SOAP进行调用
</p>
<h2 id='2.&b;消息交换模型'>
	<a></a>2.&nbsp;消息交换模型
</h2>
<h3>
	<a></a>2.1SOAP接点
</h3>
<p>
	SOAP结点表示SOAP消息路径的逻辑实体，用于进行消息路由或处理。SOAP结点可以是SOAP消息的发送者、接收方、消息中介。
</p>
<p>
	&nbsp;
</p>
<p>
	在SOAP消息模型中，中间方为一种SOAP结点，负责提供发送消息的应用程序和接收方间的消息交换和协议路由功能。中间方结点驻留在发送结点和接收结点之间，负责处理SOAP消息头中定义的部分消息。SOAP发送方和接收方之间可以有0个或多个SOAP中间方，它为SOAP接收方提供分布式处理机制。
</p>
<p>
	<img src="http://img.my.csdn.net/uploads/201211/04/1352011058_9990.png" alt="" style="height:auto;" /> 
</p>
<p>
	一般，SOAP消息中间方分为两种：
</p>
<p>
	1.&nbsp;转发中间方：这一类型的中间方通过在所转发消息的SOAP消息头块中描述和构造语义和规则，从而实现消息处理。
</p>
<p>
	2.&nbsp;活动中间方：这一类型的中间方利用一组功能为接收方结点修改外部绑定消息，从而提供更多的消息处理操作。
</p>
<p>
	在SOAP消息交换路径中，借助于SOAP中间方，使得分布式处理模型在SOAP消息交换中得以实现。通过使用SOAP中间方，可以向SOAP应用程序中集成各种功能（如转发、过滤、事务、安全、日志记录、智能路由等）。
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>2.2没有消息提供者的客户端
</h3>
<p>
	不使用消息提供者的应用程序只能交换同步消息。也就是说，扮演客户端角色的应用程序只能发送请求-响应消息。这种类型的客户端采用SAAJ&nbsp;API的SOAPConnection方法。下图演示了在没有消息提供者的情况下，同步消息如何在发送者和接收者之间交换。<br />
<img src="http://img.my.csdn.net/uploads/201211/04/1352011178_5246.gif" alt="" style="height:auto;" /> 
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图1&nbsp;不使用消息提供者的SOAP消息
</p>
<p>
	不使用消息提供者的客户端具有以下优点：&nbsp;
</p>
<p>
	&gt;&nbsp;可以采用J2SE平台编写应用程序。&nbsp;
</p>
<p>
	&gt;&nbsp;不需要在servlet或J2EE容器中部署应用程序。&nbsp;
</p>
<p>
	&gt;&nbsp;不需要配置消息提供者。&nbsp;
</p>
<p>
	不使用消息提供者的客户端具有以下局限性：&nbsp;
</p>
<p>
	&gt;&nbsp;客户端只能发送请求-响应消息&nbsp;
</p>
<p>
	&gt;&nbsp;客户端只能扮演客户端角色&nbsp;
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>2.3使用消息提供者的客户端
</h3>
<p>
	如果想要获得并且保存在任何时间发送给你的请求，你必须使用消息提供者。使用消息提供者的客户端还能发送异步消息JAXM&nbsp;API提供了使用消息提供者发送和接收消息的框架。你需要在容器中运行客户端，容器提供了消息基础结构让提供者使用。下图演示了在使用消息提供者的情况下，异步消息如何在发送者和接收者之间交换。
</p>
<p>
	<img src="http://img.my.csdn.net/uploads/201211/04/1352011331_2405.gif" alt="" style="height:auto;" /> 
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2使用消息提供者的SOAP消息
</p>
<p>
	使用消息提供者的客户端具有以下优点：
</p>
<p>
	&gt; 客户端能够扮演客户端或者服务角色&nbsp;
</p>
<p>
	&gt;&nbsp;客户端能够切换消息传递给提供者&nbsp;
</p>
<p>
	&gt;&nbsp;在客户端传递消息到最终接收者之前，它能够发送消息到一个或多个目的地。这些中间的消息接收者被称为actor，它们在消息的SOAPHeader对象中被指定。&nbsp;
</p>
<p>
	&gt;&nbsp;客户端能够利用任何提供者支持的SOAP消息协议和影响消息类型与可靠性的‘服务质量’，以及消息传递服务的质量。&nbsp;
</p>
<p>
	&nbsp;
</p>
<p>
	注意
</p>
<p>
	Sun&nbsp;Java&nbsp;System&nbsp;Application&nbsp;Server包含了一个示例JAXM提供者，它演示了如何使用提供者为发送客户端激活“发后不理（fire&nbsp;and&nbsp;forget）”消息。请察看示例文档获取关于如何激活、部署和使用它的全面信息。示例应用程序可以从以下位置得到:
</p>
<p>
	install_dir/samples/webservices/jaxm/jaxm-provider/
</p>
<p>
	Sun&nbsp;Java&nbsp;System&nbsp;Application&nbsp;Server的未来版本将会包括支持可靠SOAP消息和ebXML消息的JAXM提供者。
</p>
<p>
	&nbsp;
</p>
<h2 id='3.SOAP消息'>
	<a></a>3.SOAP消息
</h2>
<h3>
	<a></a>3.1SOAP消息的组成部分
</h3>
<p>
	所有的SOAP消息都使用XML编码，一条SOAP消息就是一个普通的XML文档，该文档包括下列元素。
</p>
<p>
	&gt;&nbsp;Envelope（信封）元素，必选，可把此XML文档标识为一条SOAP消息。
</p>
<p>
	&gt;&nbsp;Header（报头）元素，可选，包含头部信息（包含了使消息在到达最终目的地之前，能够被路由到一个或多个中间节点的信息）。
</p>
<p>
	&gt;&nbsp;Body(主体)元素，必选，包含所有的调用和响应信息。
</p>
<p>
	&gt;&nbsp;Fault元素，位于Body内，可选，提供有关处理此消息所发生错误的信息。
</p>
<p>
	&gt;&nbsp;Attachment（附件）元素，可选，可通过添加一个或多个附件扩展SOAP消息。
</p>
<p>
	<img src="http://img.my.csdn.net/uploads/201211/04/1352011605_4907.gif" alt="" style="height:auto;" /> 
</p>
<p>
	&nbsp; 图3&nbsp;SOAP消息的结构和组成部分
</p>
<p>
	SOAPMessage对象包括：
</p>
<p>
	一个SOAPPart对象，其中包括&nbsp;
</p>
<p>
	一个SOAPEnvelope对象，其中包括&nbsp;
</p>
<p>
	一个空的SOAPHeader对象&nbsp;–&nbsp;可选，包括它是为了方便，因为大多数消息都要用到它,&nbsp;SOAP头提供了向SOAP消息中添加关于这条SOAP消息的某些要素(feature)的机制。SOAP定义了少量的属性用来表明这项要素（feature）是否可选以及由谁来处理。&nbsp;
</p>
<p>
	一个空的SOAPBody对象&nbsp;-包含消息的最终接收者想要的信息的容器,可以容纳消息的内容，还能容纳包含了状态信息或者消息故障明细的错误消息。&nbsp;
</p>
<p>
	AttachmentPart可能容纳普通文本或者图像文件。&nbsp;
</p>
<p>
	&nbsp;
</p>
<p>
	SOAPEnvelope是代表消息的XML文件的根元素。它为消息如何处理、由谁处理定义了框架。XML内容从SOAPEnvelope开始。
</p>
<p>
	SOAPHeader是添加特性到SOAP消息的基本机制。它可以容纳任意数目的扩展了基础协议的子元素。例如，header子元素可能会定义认证信息、事务信息、本地信息、等等。处理消息的软件可以在没有事先约定的情况下，使用这个机制定义谁应该处理某个特性，以及该特性是强制的还是可选的。
</p>
<p>
	SOAPBody是发给消息最终接收者的强制信息的容器。SOAP消息还可以容纳一个附件，它不一定非得是XML文件。
</p>
<h3>
	<a></a>3.2SOAP消息举例
</h3>
<p>
	先来看一个简单的例子：
</p>
<p>
	在这个例子中，GetLastTradePrice&nbsp;SOAP&nbsp;请求被发往&nbsp;StockQuote服务。这个请求携带一个字符串参数ticker符号，在SOAP应答中返回一个浮点数。XML名域用来区分SOAP标志符和应用程序特定的标志符。这个例子说明了在第6节中定义的HTTP绑定。如果SOAP中管理XML负载的规则完全独立于HTTP是没有意义的，因为事实上该负载是由HTTP携带的。
</p>
<p>
	&nbsp;
</p>
<p>
	例1&nbsp;在HTTP请求中嵌入SOAP消息&nbsp;
</p>
<p>
	POST&nbsp;/StockQuote&nbsp;HTTP/1.1
</p>
<p>
	Host:&nbsp;
</p>
<p>
	www.stockquoteserver.com
</p>
<p>
	Content-Type:&nbsp;text/xml;&nbsp;
</p>
<p>
	charset="utf-8"
</p>
<p>
	Content-Length:&nbsp;nnnn
</p>
<p>
	SOAPAction:&nbsp;
</p>
<p>
	"Some-URI"
</p>
<p>
	&nbsp;
</p>
<p>
	&lt;SOAP-ENV:Envelope
</p>
<p>
	&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
</p>
<p>
	&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;m:GetLastTradePrice&nbsp;xmlns:m="Some-URI"&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;symbol&gt;DIS&lt;/symbol&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/m:GetLastTradePrice&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&gt;
</p>
<p>
	&lt;/SOAP-ENV:Envelope&gt;
</p>
<p>
	&nbsp;
</p>
<p>
	下面是一条应答消息，包括HTTP消息，SOAP消息是其具体内容：&nbsp;
</p>
<p>
	例2&nbsp;在HTTP应答中嵌入SOAP消息&nbsp;
</p>
<p>
	HTTP/1.1&nbsp;200&nbsp;OK
</p>
<p>
	Content-Type:&nbsp;text/xml;&nbsp;
</p>
<p>
	charset="utf-8"
</p>
<p>
	Content-Length:&nbsp;
</p>
<p>
	nnnn
</p>
<p>
	&nbsp;
</p>
<p>
	&lt;SOAP-ENV:Envelope
</p>
<p>
	&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
</p>
<p>
	&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;m:GetLastTradePriceResponse&nbsp;xmlns:m="Some-URI"&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Price&gt;34.5&lt;/Price&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/m:GetLastTradePriceResponse&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&gt;
</p>
<p>
	&lt;/SOAP-ENV:Envelope&gt;
</p>
<p>
	&nbsp;
</p>
<p>
	SOAP虽然是XML文档，但其编写需要满足如下语法规则：
</p>
<p>
	&gt;&nbsp;SOAP消息必须用XML来编码。
</p>
<p>
	&gt;&nbsp;SOAP消息必须用SOAP&nbsp;Envelope命名空间。
</p>
<p>
	&gt;&nbsp;SOAP消息必须用SOAP&nbsp;Encoding命名空间。
</p>
<p>
	&gt;&nbsp;SOAP消息不能包含DTD引用。
</p>
<p>
	&gt;&nbsp;SOAP消息不能包含XML处理指令。
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>3.3SOAP&nbsp;Envelope
</h3>
<p>
	SOAP&nbsp;Envelope&nbsp;是SOAP消息结构的主要容器，也是SOAP消息的根元素，它必须出现在每个SOAP消息中，用于把此XML文档标示为一条SOAP消息。
</p>
<p>
	&nbsp;
</p>
<p>
	在SOAP中，使用XML命名空间将SOAP标示符与应用程序特定的标示符区分开，将SOAP消息的元素的作用域限制在一个特定的领域。
</p>
<p>
	&lt;soap-env:Envelope&nbsp;xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/"
</p>
<p>
	&nbsp;&nbsp;Soap-env:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
</p>
<p>
	&lt;/&nbsp;soap-env:Envelope&nbsp;&gt;
</p>
<p>
	以上命名空间都是按照SOAP1.1规范书写，SOAP消息中所有元素必须由第一个命名空间进行限定，SOAP的encodingStyle属性用于定义在文档中使用的数据类型。此属性可出现在任何SOAP元素中，并会被应用到元素的内容及元素的所有子元素上。
</p>
<p>
	对于SOAP1.2规范，对应的命名空间及空信封如下：
</p>
<p>
	&lt;soap:Envelope&nbsp;xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
</p>
<p>
	&nbsp;&nbsp;soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding”&gt;
</p>
<p>
	&lt;/&nbsp;soap:Envelope&nbsp;&gt;
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>3.4SOAP&nbsp;Header
</h3>
<p>
	SOAP&nbsp;Header元素应当作为SOAPEnvelope的第一个直接子元素，它必须使用有效的命名空间。Header还可以包含0个或多个可选的子元素，这些子元素称为Header项，所有的Header项都必须是完整修饰的，即必须由一个命名空间URI和局部名组成，不允许没有命名空间修饰的Header项存在。
</p>
<p>
	&nbsp;
</p>
<p>
	Header元素用于与消息一起传输附加消息，如身份验证或事务信息。Header元素也可以包含某些属性。SOAP在默认的命名空间中定义了三个属性：actor，mustUnderstand以及encodingStyle。这些被定义在SOAP头部的属性可通知容器如何对SOAP消息进行处理。
</p>
<p>
	&lt;soap-env:Envelope&nbsp;xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/"
</p>
<p>
	&nbsp;&nbsp;Soap-env:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;soap-env:Header&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;auth:UserID&nbsp;&nbsp;xmlns:auth=”some-URI”&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Admin
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/auth:UserID&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;/soap-env:Header&gt;
</p>
<p>
	&lt;/&nbsp;soap-env:Envelope&nbsp;&gt;
</p>
<p>
	定义了新命名空间的附加元素，元素名（UserID）表明它包含身份验证信息。
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>3.5SOAP&nbsp;Body
</h3>
<p>
	SOAP消息的Body块可以包含以下任何元素：
</p>
<p>
	&gt;&nbsp;RPC方法及其参数
</p>
<p>
	&gt;&nbsp;目标应用程序（消息接收者）专用数据
</p>
<p>
	&gt;&nbsp;报告故障和状态消息的SOAP&nbsp;Fault
</p>
<p>
	所有Body元素的直接子元素都称为Body项，Body项必须由命名空间修饰。
</p>
<p>
	如下，该主体表示用于从“www.fruit.com”获取Apples的价格信息的RPC调用。
</p>
<p>
	&lt;soap-env:Envelope&nbsp;xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/"
</p>
<p>
	&nbsp;&nbsp;Soap-env:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;soap-env:Body&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;m:GetPrice&nbsp;xmlns:m=”http://www.fruit.com/prices”&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;m:Item&gt;Apples&lt;/m:Item&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&nbsp;m:GetPrice&nbsp;&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;/soap-env:Body&gt;
</p>
<p>
	&lt;/&nbsp;soap-env:Envelope&nbsp;&gt;
</p>
<p>
	命名空间http://www.fruit.com/prices是应用程序专用的元素，它们并不是SOAP标准的一部分。下面是对上述请求的响应：
</p>
<p>
	&lt;soap-env:Envelope&nbsp;xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/"
</p>
<p>
	&nbsp;&nbsp;Soap-env:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;soap-env:Body&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;m:GetPriceResponse&nbsp;xmlns:m=”http://www.fruit.com/prices”&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;m:Price&gt;3.2&lt;/m:Price&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&nbsp;m:GetPriceResponse&nbsp;&gt;
</p>
<p>
	&nbsp;&nbsp;&nbsp;&lt;/soap-env:Body&gt;
</p>
<p>
	&lt;/&nbsp;soap-env:Envelope&nbsp;&gt;
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>3.6SOAP&nbsp;Fault
</h3>
<table>
	<tbody>
		<tr>
			<td>
				<p>
					子元素
				</p>
			</td>
			<td>
				<p>
					描述
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					&lt;faultcode&gt;
				</p>
			</td>
			<td>
				<p>
					供识别故障的代码
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					&lt;faultstring&gt;
				</p>
			</td>
			<td>
				<p>
					可供人阅读的有关故障的说明
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					&lt;faultactor&gt;
				</p>
			</td>
			<td>
				<p>
					有关是谁引发故障的信息
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					&lt;detail&gt;
				</p>
			</td>
			<td>
				<p>
					存留涉及&nbsp;Body&nbsp;元素的应用程序专用错误信息
				</p>
			</td>
		</tr>
	</tbody>
</table>
<p>
	SOAP&nbsp;Fault元素用于在SOAP消息中传输错误及状态信息。如果SOAP消息需要包括SOAP&nbsp;Fault元素，它必须作为一个Body项出现，而且至多出现一次。SOAP&nbsp;Fault包括以下子元素：faultcode,faultstring,faultactor,detail.
</p>
<p>
	在下面定义的&nbsp;faultcode&nbsp;值必须用于描述错误时的&nbsp;faultcode&nbsp;元素中
</p>
<table>
	<tbody>
		<tr>
			<td>
				<p>
					错误
				</p>
			</td>
			<td>
				<p>
					描述
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					VersionMismatch
				</p>
			</td>
			<td>
				<p>
					SOAP&nbsp;Envelope&nbsp;元素的无效命名空间被发现
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					MustUnderstand
				</p>
			</td>
			<td>
				<p>
					Header&nbsp;元素的一个直接子元素
				</p>
				<p>
					（带有设置为&nbsp;"1"&nbsp;的&nbsp;mustUnderstand&nbsp;属性）无法被理解。
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					Client
				</p>
			</td>
			<td>
				<p>
					消息被不正确地构成，或包含了不正确的信息。
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p>
					Server
				</p>
			</td>
			<td>
				<p>
					服务器有问题，因此无法处理进行下去。
				</p>
			</td>
		</tr>
	</tbody>
</table>
<p>
	&nbsp;
</p>
<h3>
	<a></a>3.7附件
</h3>
<p>
	按照SOAP1.1规范的规定，SOAP消息可以包含XML格式的主SOAP信封，以及包含ASCII或二进制等任何数据格式的SOAP附件。如果SOAP消息包含附件，那么SOAP消息将是一个MIME编码的消息，它包含SOAP内容和一个或多个其他类型的附件。因此SOAP消息实际上分为以下两种类型：
</p>
<p>
	&gt;&nbsp;仅包含XML内容的消息
</p>
<p>
	&gt;&nbsp;MIME编码的消息，包含初始的XML有效内容以及任何数量的附件。这些附件可以是任何其他类型的数据。
</p>
<p>
	【MIME：Multi-purpose&nbsp;Internet&nbsp;Mail&nbsp;Extensions多用途Internet邮件扩展，是一组技术规范，其目的是使用不同字符集来传递文本，也可以在计算机之间传递各种各样的多媒体数据】
</p>
<p>
	&nbsp;
</p>
<h2 id='4.SOAP&b;HTTP&b;Bidig'>
	<a></a>4.SOAP&nbsp;HTTP&nbsp;Binding
</h2>
<h3>
	<a></a>4.1HTTP&nbsp;协议
</h3>
<p>
	HTTP&nbsp;在&nbsp;TCP/IP&nbsp;之上进行通信。HTTP&nbsp;客户机使用&nbsp;TCP&nbsp;连接到&nbsp;HTTP&nbsp;服务器。在建立连接之后，客户机可向服务器发送&nbsp;HTTP&nbsp;请求消息：
</p>
<p>
	POST&nbsp;/item&nbsp;HTTP/1.1
</p>
<p>
	Host:&nbsp;189.123.145.239
</p>
<p>
	Content-Type:&nbsp;text/plain
</p>
<p>
	Content-Length:&nbsp;200
</p>
<p>
	随后服务器会处理此请求，然后向客户机发送一个&nbsp;HTTP&nbsp;响应。此响应包含了可指示请求状态的状态代码：
</p>
<p>
	200&nbsp;OK
</p>
<p>
	Content-Type:&nbsp;text/plain
</p>
<p>
	Content-Length:&nbsp;200
</p>
<p>
	在上面的例子中，服务器返回了一个&nbsp;200&nbsp;的状态代码。这是&nbsp;HTTP&nbsp;的标准成功代码。
</p>
<p>
	假如服务器无法对请求进行解码，它可能会返回类似这样的信息：
</p>
<p>
	400&nbsp;Bad&nbsp;Request
</p>
<p>
	Content-Length:&nbsp;0
</p>
<p>
	&nbsp;
</p>
<h3>
	<a></a>4.2SOAP&nbsp;HTTP&nbsp;Binding
</h3>
<p>
	SOAP&nbsp;方法指的是遵守&nbsp;SOAP&nbsp;编码规则的&nbsp;HTTP&nbsp;请求/响应。
</p>
<p>
	HTTP&nbsp;+&nbsp;XML&nbsp;=&nbsp;SOAP
</p>
<p>
	SOAP&nbsp;请求可能是&nbsp;HTTP&nbsp;POST&nbsp;或&nbsp;HTTP&nbsp;GET&nbsp;请求。
</p>
<p>
	HTTP&nbsp;POST&nbsp;请求规定至少两个&nbsp;HTTP&nbsp;头：Content-Type&nbsp;和&nbsp;Content-Length。
</p>
<p>
	Content-Type
</p>
<p>
	SOAP&nbsp;的请求和响应的&nbsp;Content-Type&nbsp;头可定义消息的&nbsp;MIME&nbsp;类型，以及用于请求或响应的&nbsp;XML&nbsp;主体的字符编码（可选）。
</p>
<p>
	语法
</p>
<p>
	Content-Type:&nbsp;MIMEType;&nbsp;charset=character-encoding&nbsp;
</p>
<p>
	例子
</p>
<p>
	POST&nbsp;/item&nbsp;HTTP/1.1
</p>
<p>
	Content-Type:&nbsp;application/soap+xml;&nbsp;charset=utf-8
</p>
<p>
	Content-Length
</p>
<p>
	SOAP&nbsp;的请求和响应的&nbsp;Content-Length&nbsp;头规定请求或响应主体的字节数。
</p>
<p>
	语法
</p>
<p>
	Content-Length:&nbsp;bytes&nbsp;
</p>
<p>
	例子
</p>
<p>
	POST&nbsp;/item&nbsp;HTTP/1.1
</p>
<p>
	Content-Type:&nbsp;application/soap+xml;&nbsp;charset=utf-8
</p>
<p>
	Content-Length:&nbsp;250
</p></div>
      <!-- 
      <p class="diggit">
        <a href="JavaScript:makeRequest('/e/public/digg/?classid=3&amp;id=19&amp;dotop=1&amp;doajax=1&amp;ajaxarea=diggnum','EchoReturnedText','GET','');"> 很赞哦！ </a>(<b id="diggnum"><script type="text/javascript" src="/e/public/ViewClick/?classid=2&amp;id=20&amp;down=5"></script>13</b>)
      </p>
       -->

    </div>
    
    <div class="nextinfo">
      
        
        
            <p>上一篇：<a href="/p/1772.html">使用socket发送http请求(GET/POST)</a></p>
        
        
      
      
        
        
            <p>下一篇：<a href="/p/1774.html"> TIME_WAIT 状态的 TCP 连接过多的问题</a></p>
        
      
    </div>
    
    <!-- 转载声明 -->
    
        <div style="padding-left:20px;">本文转自：<a href="https://www.cnblogs.com/UniqueColor/p/5788906.html" target="_blank">https://www.cnblogs.com/UniqueColor/p/5788906.html</a></div>
    
	
	<div><!-- 添加新的评论 -->
		
   
		
		<div class="news_pl">
		    	
		  	
		</div>
	
	</div>

 
 		
	</div>

</div>

<div class="blank"></div>

	<div  style="position: fixed;display: float;top: 2px;right: 2px;width: 200px;"><!-- 评论部分 -->

		<!---->
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#1.&b;SOAP简介">1.&b;SOAP简介</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#2.&b;消息交换模型">2.&b;消息交换模型</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#3.SOAP消息">3.SOAP消息</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#4.SOAP&b;HTTP&b;Bidig">4.SOAP&b;HTTP&b;Bidig</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
		
	
		
		
	</div>

	<link href="/extends/kindeditor-4.1.10/plugins/code/prettify.css" rel="stylesheet" type="text/css"></script>
	<script charset="utf-8" src="/extends/kindeditor-4.1.10/plugins/code/prettify.js"></script>
	<script type="text/javascript">
	prettyPrint();
	</script>

<!-- 显示访问记录 -->

	<footer>
		<!-- 底部居中的 -->
		<p>Copyright © <a href="http://comonly.cn/" target="_blank">comonly.cn</a> </p>
		<p>备案号：<a href="http://www.miitbeian.gov.cn/">鄂ICP备16003690号-3</a></p>
		<div class="cnzz_bot">
			<style>
			.cnzz_bot img{
			    margin:0 auto;
			}
			</style>
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277884732'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277884732%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
		</div>
	</footer>

 
</body>
</html>
