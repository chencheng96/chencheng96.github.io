






<!doctype html>
<html>
<head>
<title>哈希函数构造 哈希冲突解决 一致性hash_comonly.cn</title>
<meta name="keywords" content="哈希函数构造 哈希冲突解决 一致性hash" />
<meta name="description" content="哈希函数的构造方法&nbsp;https://blog.csdn.net/u011037053/article/details/82080023


	


	（1）直接定址法
取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key 或 H(key)=a*key+b&nbsp; &nbsp;(a,b为常数)。


	（2）数字分析法
若关键字是以r为基的数（如：以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
（3" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="/css/css_yangqingqing.css" rel="stylesheet">
</head>
<body>
<div class="box">
 <div class="blank"></div>
 <div class="infosbox">
    <div class="newsview">
      <h3 class="news_title">哈希函数构造 哈希冲突解决 一致性hash</h3>
      <div class="bloginfo">
        <ul>
          <li class="author"></li>
          <li class="lmname"><a href="" target="_blank"></a></li>
          <li class="timer">2020-09-25</li>
          	
         
          
          <!-- origin -->
		  <li class="view">
 

	程序简版
 	  	
		  </li>		  
		  <li class="view">公开</li>

 
          <!-- 
          <li class="view">4567已阅读</li>
          <li class="like">8888888</li>
           -->
        </ul>
      </div>
      
      
        <div class="news_about"><strong>简介</strong>哈希函数的构造方法&nbsp;https://blog.csdn.net/u011037053/article/details/82080023


	


	（1）直接定址法
取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key 或 H(key)=a*key+b&nbsp; &nbsp;(a,b为常数)。


	（2）数字分析法
若关键字是以r为基的数（如：以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
（3</div>
      
      <!-- <div class="news_con"> -->
      <div class="realContent_kindeditor"> <p>
	哈希函数的构造方法&nbsp;<a href="https://blog.csdn.net/u011037053/article/details/82080023">https://blog.csdn.net/u011037053/article/details/82080023</a>
</p>
<p>
	<br />
</p>
<p>
	（1）直接定址法<br />
取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key 或 H(key)=a*key+b&nbsp; &nbsp;(a,b为常数)。
</p>
<p>
	（2）数字分析法<br />
若关键字是以r为基的数（如：以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。<br />
（3）平方取中法<br />
取关键字平方后的中间几位为哈希地址。（较常用的一种）<br />
（4）折叠法<br />
将关键字分割成位数相同的几部分（最后一部分的位数可不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。适用于关键字位数比较多，且关键字中每一位上数字分布大致均匀时。<br />
（5）除留余数法<br />
取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址（p为素数）<br />
H（key）=key&nbsp; MOD&nbsp; p，p&lt;=m&nbsp; &nbsp;（最简单，最常用）p的选取很重要<br />
一般情况，p可以选取为质数或者不包含小于20的质因数的合数（合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数）。<br />
（6）随机数法<br />
选择一个随机函数，取关键字的随机函数值为它的哈希地址。即H（key）=random（key），其中random为随机函数。适用于关键字长度不等时。<br />
总结：实际工作中根据情况不同选用的哈希函数不同，通常，考虑因素如下：<br />
（1）计算哈希函数所需时间（包括硬件指令的因素）<br />
（2）关键字的长度<br />
（3）哈希表的大小<br />
（4）关键字的分布情况<br />
（5）记录的查找频率<br />
</p>
<p>
	<br />
</p>
<p>
</p></div>
      <!-- 
      <p class="diggit">
        <a href="JavaScript:makeRequest('/e/public/digg/?classid=3&amp;id=19&amp;dotop=1&amp;doajax=1&amp;ajaxarea=diggnum','EchoReturnedText','GET','');"> 很赞哦！ </a>(<b id="diggnum"><script type="text/javascript" src="/e/public/ViewClick/?classid=2&amp;id=20&amp;down=5"></script>13</b>)
      </p>
       -->

    </div>
    
    <div class="nextinfo">
      
        
        
            <p>上一篇：<a href="/p/1755.html">汇编_压缩BCD码和非压缩BCD码</a></p>
        
        
      
      
        
        
            <p>下一篇：<a href="/p/1757.html">LRU算法实现方式</a></p>
        
      
    </div>
    
    <!-- 转载声明 -->
    
	
	<div><!-- 添加新的评论 -->
		
   
		
		<div class="news_pl">
		    <h2>文章评论</h2>	
		  	
				<ul>
					<div class="gbko">
						<span id="解决Hash冲突的方法">
							<h2 style="display:inline;color:#5BC648;">解决Hash冲突的方法</h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2020-09-25&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><p>
	<a href="https://blog.csdn.net/yu849893679/article/details/82142265">https://blog.csdn.net/yu849893679/article/details/82142265</a>
</p>
<p>
	<br />
</p>
<p>
	虽然我们不希望发生冲突，但实际上发生冲突的可能性仍是存在的。当关键字值域远大于哈希表的长度，而且事先并不知道关键字的具体取值时。冲突就难免会发 生。另外，当关键字的实际取值大于哈希表的长度时，而且表中已装满了记录，如果插入一个新记录，不仅发生冲突，而且还会发生溢出。因此，处理冲突和溢出是 哈希技术中的两个重要问题。<br />
<br />
1、开放定址法<br />
&nbsp; &nbsp; 　用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。<br />
注意：<br />
①用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。<br />
②空单元的表示与具体的应用相关。<br />
&nbsp; &nbsp; 　按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法、随机探测等。<br />
（1）线性探查法(Linear Probing)<br />
该方法的基本思想是：<br />
&nbsp; &nbsp; 将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：<br />
&nbsp; &nbsp; &nbsp; &nbsp; d，d+l，d+2，…，m-1，0，1，…，d-1<br />
&nbsp; &nbsp; 　即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。<br />
探查过程终止于三种情况：<br />
&nbsp; &nbsp; 　(1)若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；<br />
&nbsp; &nbsp; (2)若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；<br />
&nbsp; &nbsp; 　(3)若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。<br />
利用开放地址法的一般形式，线性探查法的探查序列为：<br />
&nbsp; &nbsp; &nbsp; &nbsp; hi=(h(key)+i)％m 0≤i≤m-1 //即di=i<br />
用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：<br />
① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br />
② 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。<br />
③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。<br />
（2）线性补偿探测法<br />
线性补偿探测法的基本思想是：<br />
将线性探测的步长从 1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。<br />
【例】 PDP-11 小型计算机中的汇编程序所用的符合表，就采用此方法来解决冲突，所用表长 m ＝ 1321 ，选用 Q ＝ 25 。<br />
<br />
（3）随机探测<br />
随机探测的基本思想是：<br />
将线性探测的步长从常数改为随机数，即令： j ＝ (j ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。<br />
<br />
2、拉链法<br />
（1）拉链法解决冲突的方法<br />
&nbsp; &nbsp; 　拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。<br />
【例】设有 m ＝ 5 ， H(K) ＝ K mod 5 ，关键字值序例 5 ， 21 ， 17 ， 9 ， 15 ， 36 ， 41 ， 24 ，按外链地址法所建立的哈希表如下图所示：<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 解决哈希（HASH）冲突的主要方法<br />
（2）拉链法的优点<br />
与开放定址法相比，拉链法有如下几个优点：<br />
①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br />
②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br />
③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；<br />
④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。<br />
<br />
（3）拉链法的缺点<br />
<br />
&nbsp; &nbsp; 　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指<br />
<br />
&nbsp;<br />
<br />
哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。这种方法的基本思想是：首先在元素的关键字k和元素的存储位置p之间建立一个对应关系f，使得p=f(k)，f称为哈希函数。创建哈希表时，把关键字为k的元素直接存入地址为f(k)的单元；以后当查找关键字为k的元素时，再利用哈希函数计算出该元素的存储位置p=f(k)，从而达到按关键字直接存取元素的目的。<br />
<br />
&nbsp; &nbsp;当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1≠k2 ，但 H（k1）=H（k2），这种现象称为冲突，此时称k1和k2为同义词。实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。
</p></span><!-- 内容 -->
					</div>
	      		</ul>
			
				<ul>
					<div class="gbko">
						<span id="一致性Hash算法">
							<h2 style="display:inline;color:#5BC648;">一致性Hash算法</h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2020-09-25&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><p>
	<a href="https://blog.csdn.net/cbmljs/article/details/88021598">https://blog.csdn.net/cbmljs/article/details/88021598</a>
</p>
<p>
	<br />
</p>
<p>
	一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。&nbsp;
</p>
<p>
	<br />
</p>
<p>
	环形Hash空间：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。
</p>
<p>
	<br />
把数据通过一定的hash算法处理后映射到环上，将机器通过hash算法映射到环上<br />
<br />
在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。
</p>
<p>
	<br />
</p>
<p>
	在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。<br />
<br />
机器的删除与添加<br />
<br />
普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。<br />
1. 节点（机器）的删除<br />
&nbsp; &nbsp; 以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：<br />
<br />
2. 节点（机器）的添加&nbsp;<br />
&nbsp; &nbsp; 如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中。
</p>
<p>
	<br />
</p></span><!-- 内容 -->
					</div>
	      		</ul>
			
		</div>
	
	</div>

 
 		
	</div>

</div>

<div class="blank"></div>

	<div  style="position: fixed;display: float;top: 2px;right: 2px;width: 200px;"><!-- 评论部分 -->

		<!---->
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
		
	
		评论列表
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#解决Hash冲突的方法">解决Hash冲突的方法</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#一致性Hash算法">一致性Hash算法</a></span><!-- 标题列表，快速查看-->
			</div>
		
	</div>

	<link href="/extends/kindeditor-4.1.10/plugins/code/prettify.css" rel="stylesheet" type="text/css"></script>
	<script charset="utf-8" src="/extends/kindeditor-4.1.10/plugins/code/prettify.js"></script>
	<script type="text/javascript">
	prettyPrint();
	</script>

<!-- 显示访问记录 -->

	<footer>
		<!-- 底部居中的 -->
		<p>Copyright © <a href="http://comonly.cn/" target="_blank">comonly.cn</a> </p>
		<p>备案号：<a href="http://www.miitbeian.gov.cn/">鄂ICP备16003690号-3</a></p>
		<div class="cnzz_bot">
			<style>
			.cnzz_bot img{
			    margin:0 auto;
			}
			</style>
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277884732'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277884732%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
		</div>
	</footer>

 
</body>
</html>
