






<!doctype html>
<html>
<head>
<title>计算机考研题目_comonly.cn</title>
<meta name="keywords" content="计算机考研题目" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="/css/css_yangqingqing.css" rel="stylesheet">
</head>
<body>
<div class="box">
 <div class="blank"></div>
 <div class="infosbox">
    <div class="newsview">
      <h3 class="news_title">计算机考研题目</h3>
      <div class="bloginfo">
        <ul>
          <li class="author"></li>
          <li class="lmname"><a href="" target="_blank"></a></li>
          <li class="timer">2018-03-07</li>
          	
         
          
          <!-- origin -->
		  <li class="view">
 

	本科毕业设计  考研 研究生
 	  	
		  </li>		  
		  <li class="view">公开</li>

 
          <!-- 
          <li class="view">4567已阅读</li>
          <li class="like">8888888</li>
           -->
        </ul>
      </div>
      
      
      <!-- <div class="news_con"> -->
      <div class="realContent_kindeditor"> <p>
	编程题：算法题都要求写出设计文档（算法描述、流程图之类的）
</p>
<ol>
	<li>
		实现二维数组“马鞍点”（即二维数组中某个数在所在行最大，而在所在列最小，马鞍点至多有1个，也肯能有0个）。
	</li>
	<li>
		某系统的文件组织方式是通过森林实现的，编程实现名为“abc”的目录或者文件。
	</li>
	<li>
		链表的建立，删除，添加，<cstring.h>相关。</cstring.h>
	</li>
	<li>
		某一高速交通网有若干个出口和入口。汽车可以从任意一个出口下高速或者从任意一个入口上高速。编写高速收费系统。
	</li>
	<li>
		算一个M的N次方，要求用递归。
	</li>
	<li>
		快速排序算法（要求处理N个数已有序的情况）
	</li>
	<li>
		一个8*8的棋盘上有一个骑士，骑士每次上下左右走一步，要求能不重复经过一个格子的遍历棋盘。求某种走法。（迷宫问题）
	</li>
	<li>
		某个省的一个城市出发遍历这个省的所有城市，终点要求是起点。求最短路径（图的最短路径）
	</li>
	<li>
		求函数ack(m, n)={ack(m-1,n)&nbsp; &nbsp; m!=0,n=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ack(m,n-1)&nbsp; &nbsp; m=0;n!=0;&nbsp; &nbsp; ……}计算ack函数，不能用递归，用栈来模拟递归。
	</li>
	<li>
		从键盘输入一个广义表，并把该表转化为二叉链表。
	</li>
	<li>
		简述面向对象的思想和方法，属性，类，事件，事件处理的概念。
	</li>
	<li>
		用递归求f(n)=f(n-1)+f(n-2) n&gt;2; n=1时f(n)=1; n=2时f(n)=1;
	</li>
	<li>
		键盘输入若干数字，按递减排序，并写入文件中，输入在屏幕上。
	</li>
	<li>
		在windows下实现多线程互斥，主线程休眠2秒，次线程休眠1秒。
	</li>
	<li>
		非递归遍历二叉树求单孩子节点个数。
	</li>
	<li>
		有n个孩子，第一次给某个孩子指定一个m，从1报数，直到m停下，m号孩子出列，m孩子的权值作为下一轮报数个数的终点值，且m+1号作为下一轮报数起点1。求出孩子出列序列，以及最后一个孩子出列的序号。
	</li>
	<li>
		PV操作。编写源程序。顾客进店有座位进餐，没座位等待。管理员扫描座位，有位置通知就餐。
	</li>
	<li>
		骑士走日字格式……
	</li>
	<li>
		（链表的删除插入）在一个带头结点的链表中找出最大值的元素，并且将其删去后把其最大值赋值给头结点。
	</li>
	<li>
		（栈的操作）输入一个数n，再输入n个整数，每个整数按先进后出原则（即栈）操作，要求使奇数元素全部在整数元素前打印。（可以进栈若干次后再出栈）
	</li>
	<li>
		（树的应用算法）写出一个判断平衡二叉树的算法。
	</li>
	<li>
		（谓词证明）这个题很简单，给出了前提与结论自己套公式，用的公式是假言推理
	</li>
</ol>
<p>
	离散：
</p>
<ol>
	<li>
		研究生都是统考或推免生，所有推免生本科课程一定学的好，并非所有研究生本科课程都学得好，那么研究生中存在统考生。
	</li>
	<li>
		G是一个群，a,b属于G，a。b=a*x*b，x属于G，证明也是群
	</li>
	<li>
		R是A上的关系，且B包含于A，S=R交B乘B，证明S是B上的关系。
	</li>
	<li>
		证明6个人中或者有三个人互相全部认识，或者有3个全部互相不认识。
	</li>
	<li>
		（树的证明）证明正则二叉树只有奇数个顶点偶数条边。
	</li>
	<li>
		（Abel群，这个超纲）<g,*>是群,任意a,b属于G，有a^3*b^3=(a*b)^3, a^4*b^4=(a*b)^4, a^5*b^5=(a*b)^5,最后证明<g,*>是阿贝尔群。</g,*></g,*>
	</li>
</ol>
<p>
	机试：
</p>
<ol>
	<li>
		信用卡号码检验：信用卡号码满足，倒数第1,3,5……位的和加上倒数2,4,6位数字乘以2（如果乘以2后变成两位数，则减9）的和。能被10整除。任意输入一个数字串，检验是否满足条件。
	</li>
	<li>
		1□2□3□4□5□6□7□8□9=110要求在中间的8个空中填写+，-或不填。构成的表达式判断是不是正确，正确则输出。
	</li>
	<li>
		循环矩阵（第一列和最后一列相邻），求矩阵中最大子矩阵（子矩阵中的元素和最大）。输入数据在input.txt中读取，输出结果存入output.txt中。import java.io.*&nbsp; &nbsp; 1 1 0 2&nbsp; &nbsp; 5 1 -3 1&nbsp; &nbsp; 2 2 -1 4&nbsp; &nbsp; -7 -8 0 -5
	</li>
	<li>
		n个人围坐一圈，每个人指派ri个礼物，每个人得到的礼物根旁边相邻的人不能有任何相同的一个，n个人最少需要多少个礼物指派。
	</li>
	<li>
		小明玩一个游戏，小明手上有一张牌，桌子上有六张牌，游戏规则是，求用最多的桌上卡牌与小明手中的卡牌进行加减乘除四则运算 最后使结果达到13.如小明卡牌是5，桌上卡牌是1 3 9 4 2 2，此题答案即5+1/3+9+4-2即最多可容纳5张牌（此题不考乘除优先级，先到优先，桌上卡牌可重）。从input.txt中读入数据		往output.txt中写入数据&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 3 9 4 2 2	5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5+1/3+9+4-2
	</li>
</ol>
<p>
	编译原理：
</p>
<ol>
	<li>
		NFA化为DFA（NFA有两个初始态）
	</li>
	<li>
		代码优化，画DAG图，然后优化，转化成三地址式。
	</li>
	<li>
		判断是不是满足slr，满足就画表。
	</li>
	<li>
		分析一个简单的文法，转化成LL（1）文法，（其实就是消除左递归和提公因子，检验一下first和follow集，满足）
	</li>
</ol></div>
      <!-- 
      <p class="diggit">
        <a href="JavaScript:makeRequest('/e/public/digg/?classid=3&amp;id=19&amp;dotop=1&amp;doajax=1&amp;ajaxarea=diggnum','EchoReturnedText','GET','');"> 很赞哦！ </a>(<b id="diggnum"><script type="text/javascript" src="/e/public/ViewClick/?classid=2&amp;id=20&amp;down=5"></script>13</b>)
      </p>
       -->

    </div>
    
    <div class="nextinfo">
      
        
        
            <p>上一篇：<a href="/p/867.html">Python GUI程序设计</a></p>
        
        
      
      
        
        
            <p>下一篇：<a href="/p/870.html">复试大纲及线</a></p>
        
      
    </div>
    
    <!-- 转载声明 -->
    
	
	<div><!-- 添加新的评论 -->
		
   
		
		<div class="news_pl">
		    <h2>文章评论</h2>	
		  	
				<ul>
					<div class="gbko">
						<span id="机试参考解决方案">
							<h2 style="display:inline;color:#5BC648;">机试参考解决方案</h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-03-10&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><pre class="prettyprint lang-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
void bankcount();
void op();
void maxdi();
int getmax(int arr[][4],int);
void giftDiffer();
void cardOp();
void main()
{
	//bankcount();
	//op();
	//maxdi();
	giftDiffer();
	//cardOp();
}
//////////////////////////////////////////////////////////////
void bankcount()
{
	//信用卡号码检验：信用卡号码满足，倒数第1,3,5……位的和
	//加上倒数2,4,6位数字乘以2（如果乘以2后变成两位数，则减9）的和。
	//能被10整除。任意输入一个数字串，检验是否满足条件。
	long int temp=0;

	int i;	//计数
	char snum[20];

	scanf("%s",&amp;snum);

	i=strlen(snum)-1;
	for(;i&gt;=0;i=i-2)
		temp+=snum[i]-'0';
	i=strlen(snum)-2;
	for(;i&gt;=0;i=i-2)
		if(2*(snum[i]-'0')&gt;=10)temp+=2*(snum[i]-'0')-9;
		else temp+=2*(snum[i]-'0');

	if(temp%10==0)printf("%d, success\n",temp);
	else printf("%d, Error!\n",temp);
}

void op()
{
	//1□2□3□4□5□6□7□8□9=110要求在中间的8个空中填写+，-或不填。
	//构成的表达式判断是不是正确，正确则输出。

	//第一个框为te[1]
	int sum=0;
	int now=1;
	int i,i1,i2,i3,i4,i5,i6,i7,i8;
	char te[9]="+++++++++";
	char rol[3]="+- ";
	//te[1]=rol[1];
	//printf("%c\n",te[1]);
	for(i1=0;i1&lt;3;i1++){te[1]=rol[i1];//i1++是在for后赋值的！！！！！！！！！！！！！！！！！！
		for(i2=0;i2&lt;3;i2++){te[2]=rol[i2];
			for(i3=0;i3&lt;3;i3++){te[3]=rol[i3];
				for(i4=0;i4&lt;3;i4++){te[4]=rol[i4];
					for(i5=0;i5&lt;3;i5++){te[5]=rol[i5];
						for(i6=0;i6&lt;3;i6++){te[6]=rol[i6];
							for(i7=0;i7&lt;3;i7++){te[7]=rol[i7];
								for(i8=0;i8&lt;3;i8++){te[8]=rol[i8];

	//printf("%s\n",te);
	sum=0;now=1;
	//for(;i&lt;=9;i++)scanf("%c",te[i]);
	for(i=1;i&lt;9;i++)
	{
		if(te[i]==' ')
		{if(now&lt;0)now=now*10-i-1;else now=now*10+i+1;}
		else if(te[i]=='+'){sum+=now;now=i+1;}//printf("%d,",sum);}
		else {sum+=now;now=-(i+1);}
	}
	sum+=now;
	if(sum==110)printf("1%c2%c3%c4%c5%c6%c7%c8%c9=%d\n",te[1],te[2],te[3],te[4],te[5],te[6],te[7],te[8],sum);
	}}}}}}}}

}


void maxdi()
{
	//循环矩阵（第一列和最后一列相邻），求矩阵中最大子矩阵（子矩阵中的元素和最大）。
	//输入数据在input.txt中读取，输出结果存入output.txt中。
	//import java.io.*    1 1 0 2    5 1 -3 1    2 2 -1 4    -7 -8 0 -5

	int i,j;//计数
	int max;//子矩阵的最大和。
	FILE *in,*out;
	char ch[50];	//换成*ch看效果
	int arr[4][4],*pointarr,arrtemp[4][4];
	char * p;//分割字符串
	char * delim=" \n";//分隔符字符串


	if((in=fopen("input.txt","r"))==NULL)	//打开文件
	{
		printf("open Error!\n");
		exit(0);
	}
	if((out=fopen("output.txt","w"))==NULL)
	{
		printf("open Error!\n");
		exit(0);
	}


	//直接读取所有的数据存为字符串。
	//从文件读取一个负数！！！！

	pointarr=arr;

	while(!feof(in))
	{
		fgets(ch,20,in);
		//获取待分解字符串，每次读取一行!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		p=strtok(ch,delim);	//第一次调用strtok
		while(p!=NULL)	//当返回值不为NULL时，继续循环
		{
			*pointarr=atoi(p);pointarr++;
			//将获取的一行数据,每次用atoi将获得的字符串格式数字转换为int。存入pointarr指向的数组arr中。
			p=strtok(NULL,delim);//继续调用strtok，分解剩下的字符串
		}
		//fscanf(文件指针，格式化字符串，输入表列)
	}

	pointarr=arr;
	for(i=0;i&lt;4;i++)
		for(j=0;j&lt;4;j++)	
			{printf("%d  ",*pointarr);pointarr++;}
	puts("\n");	

	max=getmax(arr,0);
	//修改数组组成……将最后列移到第一列，然后再3次arr，求出最大即为最大
	for(i=0;i&lt;4;i++)
		for(j=0;j&lt;4;j++)	
			{arrtemp[i][(j+1)%4]=arr[i][j];}
	max=getmax(arrtemp,1);

	for(i=0;i&lt;4;i++)
		for(j=0;j&lt;4;j++)	
			{arrtemp[i][(j+2)%4]=arr[i][j];}
	max=getmax(arrtemp,2);

	for(i=0;i&lt;4;i++)
		for(j=0;j&lt;4;j++)	
			{arrtemp[i][(j+3)%4]=arr[i][j];}
	max=getmax(arrtemp,3);

	//rewind(in);

	//fputs(str,out);		//通过字符串进行输入输出
	//putchar(10);	//输出换行符
	fclose(in);
	fclose(out);
}

int getmax(int arr[4][4],int rightmove)			//矩阵右移多少位。
{
	//求出某方阵的最大矩阵
	int maxSum=arr[0][0],sum=0;
	int ei1,ej1,ei2,ej2;//记录最后的坐标
	int i1,j1,i2,j2;//i为行j为列。分别表示矩阵的左上角坐标和由下角坐标。
	int m,n;//当前遍历到的行列。
	
	for(i1=0;i1&lt;4;i1++)
		for(i2=i1;i2&lt;4;i2++)
			for(j1=0;j1&lt;4;j1++)
				for(j2=j1;j2&lt;4;j2++)
				{
	sum=0;
	//i1=j1=0;i2=j2=1;
	for(m=i1;m&lt;=i2;m++)//给定的坐标求和
		for(n=j1;n&lt;=j2;n++)
			sum+=arr[m][n];
	if(sum&gt;maxSum){maxSum=sum;ei1=i1;ej1=j1;ei2=i2;ej2=j2;}
				}
				
	printf("%d		起点：%d，%d		终点：%d，%d\n",
		maxSum,ei1,ej1-rightmove,ei2,ej2-rightmove);
	return maxSum;

}


//染色问题///////////////////////////////////////
int overlap(int b1, int e1, int b2, int e2) {
	//判断两区间是否有重叠的函数
    if (b2 &gt;= e1 || b1 &gt;= e2)
        return 0;      //没有重叠
    else
        return 1;      //有重叠
}

int intervalColoring(int b[], int e[], int color[], int N)
{
    int nMaxColors = 0, i, k, j;
    int isForbidden[4];//false:0;true:1
    memset(isForbidden, 0, sizeof isForbidden);

    for (i = 0; i &lt; N;i++) {
        for (k = 0;k &lt; nMaxColors;k++)  /** a */
            isForbidden[k] = 0;
        for (j = 0;j &lt; i;j++)           /** b */
            if (overlap(b[j], e[j], b[i], e[i]))
                isForbidden[color[j]] = 1;
        for (k = 0;k &lt; nMaxColors;k++)  /** c */
            if (isForbidden[color[k]] == 0)
                break;
        if (k &lt; nMaxColors)
            color[i] = k;
        else {
            color[i] = nMaxColors;
            ++nMaxColors;
        }
    }// for
    return nMaxColors;
}

void giftDiffer()
{
	//n个人围坐一圈，每个人指派ri个礼物，每个人得到的礼物跟旁边
	//相邻的人不能有任何相同的一个，n个人最少需要多少个礼物指派。

	int overlap(int b1, int e1, int b2, int e2);
	int intervalColoring(int b[], int e[], int color[], int N);
    int i, N= 4; 
	int color[4],nMaxColors= 0;
    int b[] = {1, 2, 3, 3}, e[] = {5, 3, 4, 6};
    nMaxColors = intervalColoring(b, e, color, N);

    printf("nMaxColors = %d\n", nMaxColors);
    printf("\ncolor of the intervals:\n");
    for (i = 0;i &lt; N;i++)
        printf("interval %d: color %d\n",i, color[i]);


}



void cardOp()
{
	//手上有一张牌，桌子上六张牌，求用最多的桌上卡牌与小明手中的卡牌进行
	//加减乘除四则运算 最后使结果达到13.如小明卡牌是5，桌上卡牌是1 3 9 4 2 2，
	//此题答案即5+1/3+9+4-2即最多可容纳5张牌（此题不考乘除优先级，先到优先，
	//桌上卡牌可重）。从input.txt中读入数据	往output.txt中写入数据
	//5  1 3 9 4 2 2			 5   5+1/3+9+4-2

	FILE *in,*out;
	char ch[20],a;
	int arr[7];//存放牌数
	char * p;//分割字符串
	int i;//计数
	int sum;
	int tempsum1,tempsum2,tempsum3,tempsum4,tempsum5,tempsum6;
	int i1,i2,i3,i4,i5,i6;//计数
	char c1,c2,c3,c4,c5,c6;
	char * delim=" \n";//分隔符字符串
	if((in=fopen("cardin.txt","r"))==NULL){exit(0);};

	i=0;
	while(!feof(in))
	{
		a=fgetc(in);ch[0]=a;ch[1]=" ";
		//arr[i]=atoi(ch);//atoi只能用于字符串数组或指针
		if(a&gt;='0'&amp;&amp;a&lt;='9'){arr[i]=a-'0';printf("%d	",arr[i]);i++;}
	}
	fclose(in);

	if((out=fopen("cardout.txt","w"))==NULL)exit(0);

	sum=arr[0];
	tempsum1=sum;
	for(i1=1;i1&lt;=5;i1++)//i5等于0表示符号后的数字不要
	{
		if(i1==4 &amp;&amp; tempsum1%arr[1]!=0)break;
		switch(i1)
		{
		case 1:sum=tempsum1+arr[1];c1='+';break;
		case 2:sum=tempsum1-arr[1];c1='-';break;
		case 3:sum=tempsum1*arr[1];c1='*';break;
		case 4:sum=tempsum1/arr[1];c1='/';break;
		case 5:c1='@';sum=tempsum1;break;
		}

		tempsum2=sum;
		for(i2=1;i2&lt;=4;i2++)
		{
			if(i2==4 &amp;&amp; tempsum2%arr[2]!=0)break;
			switch(i2)
			{
			case 1:sum=tempsum2+arr[2];c2='+';break;
			case 2:sum=tempsum2-arr[2];c2='-';break;
			case 3:sum=tempsum2*arr[2];c2='*';break;
			case 4:sum=tempsum2/arr[2];c2='/';break;
				case 5:c2='@';sum=tempsum2;break;
			}

			tempsum3=sum;
			for(i3=1;i3&lt;=4;i3++)
			{
				if(i3==4 &amp;&amp; tempsum3%arr[3]!=0)break;
				switch(i3)
				{
				case 1:sum=tempsum3+arr[3];c3='+';break;
				case 2:sum=tempsum3-arr[3];c3='-';break;
				case 3:sum=tempsum3*arr[3];c3='*';break;
				case 4:sum=tempsum3/arr[3];c3='/';break;
					case 5:c3='@';sum=tempsum3;break;
				}

				tempsum4=sum;
				for(i4=1;i4&lt;=4;i4++)
				{
					if(i4==4 &amp;&amp; tempsum4%arr[4]!=0)break;
					switch(i4)
					{
					case 1:sum=tempsum4+arr[4];c4='+';break;
					case 2:sum=tempsum4-arr[4];c4='-';break;
					case 3:sum=tempsum4*arr[4];c4='*';break;
					case 4:sum=tempsum4/arr[4];c4='/';break;
						case 5:c4='@';sum=tempsum4;break;
					}

					tempsum5=sum;
					for(i5=1;i5&lt;=4;i5++)
					{
						if(i5==4 &amp;&amp; tempsum5%arr[5]!=0)break;
						switch(i5)
						{
						case 1:sum=tempsum5+arr[5];c5='+';break;
						case 2:sum=tempsum5-arr[5];c5='-';break;
						case 3:sum=tempsum5*arr[5];c5='*';break;
						case 4:sum=tempsum5/arr[5];c5='/';break;
							case 5:c5='@';sum=tempsum5;break;
						}
						
						tempsum6=sum;
						for(i6=1;i6&lt;=4;i6++)
						{
							if(i6==4 &amp;&amp; tempsum6%arr[6]!=0)break;
							switch(i6)
							{
							case 1:sum=tempsum6+arr[6];c6='+';break;
							case 2:sum=tempsum6-arr[6];c6='-';break;
							case 3:sum=tempsum6*arr[6];c6='*';break;
							case 4:sum=tempsum6/arr[6];c6='/';break;
								case 5:c6='@';sum=tempsum6;break;
							}

							if(sum==13)
							{
								printf("%d%c%d%c%d%c%d%c%d%c%d%c%d=13\n",
									arr[0],c1,arr[1],c2,arr[2],c3,arr[3],
									c4,arr[4],c5,arr[5],c6,arr[6]);
								fprintf(out,"%d%c%d%c%d%c%d%c%d%c%d%c%d=13\n",
									arr[0],c1,arr[1],c2,arr[2],c3,arr[3],c4,
									arr[4],c5,arr[5],c6,arr[6]);
						
							}
						}
					}
				}
			}
		
		}
	}
	fclose(out);

}</pre></span><!-- 内容 -->
					</div>
	      		</ul>
			
				<ul>
					<div class="gbko">
						<span id="线性链表创建,删除,修改,二进制文件,重命名,">
							<h2 style="display:inline;color:#5BC648;">线性链表创建,删除,修改,二进制文件,重命名,</h2>
							&nbsp;&nbsp;&nbsp;&nbsp;2018-03-28&nbsp;&nbsp;&nbsp;&nbsp;
								
						</span><!-- 标题，时间 -->
						
						<br/>
						<span><pre class="prettyprint lang-cpp">#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt;
//#include&lt;malloc.h&gt;
typedef struct List
{
	int count;
	struct List * next;
}List; void initList(List *L); void viewList(List L);
void delect(int count,List *L);
void saveList(List L); void main()
{
	List *p;
	List grade;
	grade.count=0;grade.next=NULL;
	p=&amp;grade;

	initList(&amp;grade);
	printf("初始化时grade指向的链表的值：");
	viewList(grade);

	printf("删除grade中 30 后的链表的值：");
	delect(30,p);
	viewList(grade);

	saveList(grade);

}

void saveList(List L)
{
	FILE *fp;
	int i=0;
	List *p=&amp;L;
	List *read=(List *)malloc(sizeof(List));

	if(access("20180324",0))mkdir("20180324");
	if((fp=fopen("20180324/my.dat","w+"))==NULL)exit(0);

	while(p!=NULL)	//二进制形式存储文件
	{
		fwrite(p,sizeof(List),1,fp);
		p=p-&gt;next;
		i++;
	}
	
	rewind(fp);

	printf("流式文件读取：");
	for(;i&gt;0;i--)	//二进制形式读取文件
	{
		fread(read,sizeof(List),1,fp);
		printf("%d ",read-&gt;count);
	}
	putchar('\n');
	
	fclose(fp);

	printf("修改名字状态%d\n",rename("20180324/my.dat","20180324/my.txt"));
	//rename(old,new).修改文件名字，需要在文件关闭状态。

	printf("删除文件状态%d\n",remove("20180324/my.txt"));
       //remove(name)删除文件
	
	//文件内容的删除与修改的一个策略，从源文件中读取内容。
	//判断后写入一个新文件，最后再对新文件重命名

}

void initList(List *L)
{
	int i;
	List *p=L;
	for(i=1;i&lt;=10;i++)
	{
		L-&gt;count++;//带头结点，记录链表长度
		p=(List *)malloc(sizeof(List));
		p-&gt;count=i*3;

		p-&gt;next=L-&gt;next;
		L-&gt;next=p;
	}
}

void viewList(List L)
{
	List *p=&amp;L;
	while(p != NULL)
	{
		printf("%d ",p-&gt;count);
		p=p-&gt;next;
	}
	putchar('\n');
}

void delect(int count,List *L)
{//从链表删除值为count的结点，参数应为指针
	List *q;
	List *p=L;
	//while(p-&gt;count==count){L=*L.next;free(p);p=&amp;L;}
	q=p-&gt;next;		
	while(q != NULL)
	{
		if(q-&gt;count==count)
		{
			p-&gt;next=q-&gt;next;
			free(q);
			q=p-&gt;next;
			L-&gt;count--;
		}
		else 
		{
			q=q-&gt;next;
			p=p-&gt;next;
		}
	}
}</pre></span><!-- 内容 -->
					</div>
	      		</ul>
			
		</div>
	
	</div>

 
 		
	</div>

</div>

<div class="blank"></div>

	<div  style="position: fixed;display: float;top: 2px;right: 2px;width: 200px;"><!-- 评论部分 -->

		<!---->
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
		
	
		评论列表
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#机试参考解决方案">机试参考解决方案</a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#线性链表创建,删除,修改,二进制文件,重命名,">线性链表创建,删除,修改,二进制文件,重命名,</a></span><!-- 标题列表，快速查看-->
			</div>
		
	</div>

	<link href="/extends/kindeditor-4.1.10/plugins/code/prettify.css" rel="stylesheet" type="text/css"></script>
	<script charset="utf-8" src="/extends/kindeditor-4.1.10/plugins/code/prettify.js"></script>
	<script type="text/javascript">
	prettyPrint();
	</script>

<!-- 显示访问记录 -->

	<footer>
		<!-- 底部居中的 -->
		<p>Copyright © <a href="http://comonly.cn/" target="_blank">comonly.cn</a> </p>
		<p>备案号：<a href="http://www.miitbeian.gov.cn/">鄂ICP备16003690号-3</a></p>
		<div class="cnzz_bot">
			<style>
			.cnzz_bot img{
			    margin:0 auto;
			}
			</style>
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277884732'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277884732%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
		</div>
	</footer>

 
</body>
</html>
